
MC2_code.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002298  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000022  00800060  00002298  0000232c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  00800082  00800082  0000234e  2**0
                  ALLOC
  3 .stab         00002838  00000000  00000000  00002350  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001466  00000000  00000000  00004b88  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000140  00000000  00000000  00005fee  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 00000170  00000000  00000000  0000612e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00001c49  00000000  00000000  0000629e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00000eeb  00000000  00000000  00007ee7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00000dad  00000000  00000000  00008dd2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000160  00000000  00000000  00009b80  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000028d  00000000  00000000  00009ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000007ce  00000000  00000000  00009f6d  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0000a73b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 22 0f 	jmp	0x1e44	; 0x1e44 <__vector_4>
      14:	0c 94 ef 0e 	jmp	0x1dde	; 0x1dde <__vector_5>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 bc 0e 	jmp	0x1d78	; 0x1d78 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 89 0e 	jmp	0x1d12	; 0x1d12 <__vector_9>
      28:	0c 94 56 0e 	jmp	0x1cac	; 0x1cac <__vector_10>
      2c:	0c 94 23 0e 	jmp	0x1c46	; 0x1c46 <__vector_11>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e9       	ldi	r30, 0x98	; 152
      68:	f2 e2       	ldi	r31, 0x22	; 34
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	a2 38       	cpi	r26, 0x82	; 130
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	10 e0       	ldi	r17, 0x00	; 0
      78:	a2 e8       	ldi	r26, 0x82	; 130
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	aa 38       	cpi	r26, 0x8A	; 138
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <main>
      8a:	0c 94 4a 11 	jmp	0x2294	; 0x2294 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 49 03 	call	0x692	; 0x692 <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 a9 03 	call	0x752	; 0x752 <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 13 11 	jmp	0x2226	; 0x2226 <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a0 e6       	ldi	r26, 0x60	; 96
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 2f 11 	jmp	0x225e	; 0x225e <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 13 11 	jmp	0x2226	; 0x2226 <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	80 e6       	ldi	r24, 0x60	; 96
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 fd 03 	call	0x7fa	; 0x7fa <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 2f 11 	jmp	0x225e	; 0x225e <__epilogue_restores__>

00000632 <__gtsf2>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__prologue_saves__+0x18>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	89 e0       	ldi	r24, 0x09	; 9
     650:	e8 2e       	mov	r14, r24
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     672:	89 85       	ldd	r24, Y+9	; 0x09
     674:	82 30       	cpi	r24, 0x02	; 2
     676:	40 f0       	brcs	.+16     	; 0x688 <__gtsf2+0x56>
     678:	89 89       	ldd	r24, Y+17	; 0x11
     67a:	82 30       	cpi	r24, 0x02	; 2
     67c:	28 f0       	brcs	.+10     	; 0x688 <__gtsf2+0x56>
     67e:	c7 01       	movw	r24, r14
     680:	b8 01       	movw	r22, r16
     682:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     686:	01 c0       	rjmp	.+2      	; 0x68a <__gtsf2+0x58>
     688:	8f ef       	ldi	r24, 0xFF	; 255
     68a:	68 96       	adiw	r28, 0x18	; 24
     68c:	e6 e0       	ldi	r30, 0x06	; 6
     68e:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <__epilogue_restores__+0x18>

00000692 <__gesf2>:
     692:	a8 e1       	ldi	r26, 0x18	; 24
     694:	b0 e0       	ldi	r27, 0x00	; 0
     696:	ef e4       	ldi	r30, 0x4F	; 79
     698:	f3 e0       	ldi	r31, 0x03	; 3
     69a:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__prologue_saves__+0x18>
     69e:	69 83       	std	Y+1, r22	; 0x01
     6a0:	7a 83       	std	Y+2, r23	; 0x02
     6a2:	8b 83       	std	Y+3, r24	; 0x03
     6a4:	9c 83       	std	Y+4, r25	; 0x04
     6a6:	2d 83       	std	Y+5, r18	; 0x05
     6a8:	3e 83       	std	Y+6, r19	; 0x06
     6aa:	4f 83       	std	Y+7, r20	; 0x07
     6ac:	58 87       	std	Y+8, r21	; 0x08
     6ae:	89 e0       	ldi	r24, 0x09	; 9
     6b0:	e8 2e       	mov	r14, r24
     6b2:	f1 2c       	mov	r15, r1
     6b4:	ec 0e       	add	r14, r28
     6b6:	fd 1e       	adc	r15, r29
     6b8:	ce 01       	movw	r24, r28
     6ba:	01 96       	adiw	r24, 0x01	; 1
     6bc:	b7 01       	movw	r22, r14
     6be:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6c2:	8e 01       	movw	r16, r28
     6c4:	0f 5e       	subi	r16, 0xEF	; 239
     6c6:	1f 4f       	sbci	r17, 0xFF	; 255
     6c8:	ce 01       	movw	r24, r28
     6ca:	05 96       	adiw	r24, 0x05	; 5
     6cc:	b8 01       	movw	r22, r16
     6ce:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     6d2:	89 85       	ldd	r24, Y+9	; 0x09
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	40 f0       	brcs	.+16     	; 0x6e8 <__gesf2+0x56>
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	82 30       	cpi	r24, 0x02	; 2
     6dc:	28 f0       	brcs	.+10     	; 0x6e8 <__gesf2+0x56>
     6de:	c7 01       	movw	r24, r14
     6e0:	b8 01       	movw	r22, r16
     6e2:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     6e6:	01 c0       	rjmp	.+2      	; 0x6ea <__gesf2+0x58>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	68 96       	adiw	r28, 0x18	; 24
     6ec:	e6 e0       	ldi	r30, 0x06	; 6
     6ee:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <__epilogue_restores__+0x18>

000006f2 <__ltsf2>:
     6f2:	a8 e1       	ldi	r26, 0x18	; 24
     6f4:	b0 e0       	ldi	r27, 0x00	; 0
     6f6:	ef e7       	ldi	r30, 0x7F	; 127
     6f8:	f3 e0       	ldi	r31, 0x03	; 3
     6fa:	0c 94 1f 11 	jmp	0x223e	; 0x223e <__prologue_saves__+0x18>
     6fe:	69 83       	std	Y+1, r22	; 0x01
     700:	7a 83       	std	Y+2, r23	; 0x02
     702:	8b 83       	std	Y+3, r24	; 0x03
     704:	9c 83       	std	Y+4, r25	; 0x04
     706:	2d 83       	std	Y+5, r18	; 0x05
     708:	3e 83       	std	Y+6, r19	; 0x06
     70a:	4f 83       	std	Y+7, r20	; 0x07
     70c:	58 87       	std	Y+8, r21	; 0x08
     70e:	89 e0       	ldi	r24, 0x09	; 9
     710:	e8 2e       	mov	r14, r24
     712:	f1 2c       	mov	r15, r1
     714:	ec 0e       	add	r14, r28
     716:	fd 1e       	adc	r15, r29
     718:	ce 01       	movw	r24, r28
     71a:	01 96       	adiw	r24, 0x01	; 1
     71c:	b7 01       	movw	r22, r14
     71e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     722:	8e 01       	movw	r16, r28
     724:	0f 5e       	subi	r16, 0xEF	; 239
     726:	1f 4f       	sbci	r17, 0xFF	; 255
     728:	ce 01       	movw	r24, r28
     72a:	05 96       	adiw	r24, 0x05	; 5
     72c:	b8 01       	movw	r22, r16
     72e:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     732:	89 85       	ldd	r24, Y+9	; 0x09
     734:	82 30       	cpi	r24, 0x02	; 2
     736:	40 f0       	brcs	.+16     	; 0x748 <__ltsf2+0x56>
     738:	89 89       	ldd	r24, Y+17	; 0x11
     73a:	82 30       	cpi	r24, 0x02	; 2
     73c:	28 f0       	brcs	.+10     	; 0x748 <__ltsf2+0x56>
     73e:	c7 01       	movw	r24, r14
     740:	b8 01       	movw	r22, r16
     742:	0e 94 4a 05 	call	0xa94	; 0xa94 <__fpcmp_parts_f>
     746:	01 c0       	rjmp	.+2      	; 0x74a <__ltsf2+0x58>
     748:	81 e0       	ldi	r24, 0x01	; 1
     74a:	68 96       	adiw	r28, 0x18	; 24
     74c:	e6 e0       	ldi	r30, 0x06	; 6
     74e:	0c 94 3b 11 	jmp	0x2276	; 0x2276 <__epilogue_restores__+0x18>

00000752 <__fixsfsi>:
     752:	ac e0       	ldi	r26, 0x0C	; 12
     754:	b0 e0       	ldi	r27, 0x00	; 0
     756:	ef ea       	ldi	r30, 0xAF	; 175
     758:	f3 e0       	ldi	r31, 0x03	; 3
     75a:	0c 94 23 11 	jmp	0x2246	; 0x2246 <__prologue_saves__+0x20>
     75e:	69 83       	std	Y+1, r22	; 0x01
     760:	7a 83       	std	Y+2, r23	; 0x02
     762:	8b 83       	std	Y+3, r24	; 0x03
     764:	9c 83       	std	Y+4, r25	; 0x04
     766:	ce 01       	movw	r24, r28
     768:	01 96       	adiw	r24, 0x01	; 1
     76a:	be 01       	movw	r22, r28
     76c:	6b 5f       	subi	r22, 0xFB	; 251
     76e:	7f 4f       	sbci	r23, 0xFF	; 255
     770:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <__unpack_f>
     774:	8d 81       	ldd	r24, Y+5	; 0x05
     776:	82 30       	cpi	r24, 0x02	; 2
     778:	61 f1       	breq	.+88     	; 0x7d2 <__fixsfsi+0x80>
     77a:	82 30       	cpi	r24, 0x02	; 2
     77c:	50 f1       	brcs	.+84     	; 0x7d2 <__fixsfsi+0x80>
     77e:	84 30       	cpi	r24, 0x04	; 4
     780:	21 f4       	brne	.+8      	; 0x78a <__fixsfsi+0x38>
     782:	8e 81       	ldd	r24, Y+6	; 0x06
     784:	88 23       	and	r24, r24
     786:	51 f1       	breq	.+84     	; 0x7dc <__fixsfsi+0x8a>
     788:	2e c0       	rjmp	.+92     	; 0x7e6 <__fixsfsi+0x94>
     78a:	2f 81       	ldd	r18, Y+7	; 0x07
     78c:	38 85       	ldd	r19, Y+8	; 0x08
     78e:	37 fd       	sbrc	r19, 7
     790:	20 c0       	rjmp	.+64     	; 0x7d2 <__fixsfsi+0x80>
     792:	6e 81       	ldd	r22, Y+6	; 0x06
     794:	2f 31       	cpi	r18, 0x1F	; 31
     796:	31 05       	cpc	r19, r1
     798:	1c f0       	brlt	.+6      	; 0x7a0 <__fixsfsi+0x4e>
     79a:	66 23       	and	r22, r22
     79c:	f9 f0       	breq	.+62     	; 0x7dc <__fixsfsi+0x8a>
     79e:	23 c0       	rjmp	.+70     	; 0x7e6 <__fixsfsi+0x94>
     7a0:	8e e1       	ldi	r24, 0x1E	; 30
     7a2:	90 e0       	ldi	r25, 0x00	; 0
     7a4:	82 1b       	sub	r24, r18
     7a6:	93 0b       	sbc	r25, r19
     7a8:	29 85       	ldd	r18, Y+9	; 0x09
     7aa:	3a 85       	ldd	r19, Y+10	; 0x0a
     7ac:	4b 85       	ldd	r20, Y+11	; 0x0b
     7ae:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b0:	04 c0       	rjmp	.+8      	; 0x7ba <__fixsfsi+0x68>
     7b2:	56 95       	lsr	r21
     7b4:	47 95       	ror	r20
     7b6:	37 95       	ror	r19
     7b8:	27 95       	ror	r18
     7ba:	8a 95       	dec	r24
     7bc:	d2 f7       	brpl	.-12     	; 0x7b2 <__fixsfsi+0x60>
     7be:	66 23       	and	r22, r22
     7c0:	b1 f0       	breq	.+44     	; 0x7ee <__fixsfsi+0x9c>
     7c2:	50 95       	com	r21
     7c4:	40 95       	com	r20
     7c6:	30 95       	com	r19
     7c8:	21 95       	neg	r18
     7ca:	3f 4f       	sbci	r19, 0xFF	; 255
     7cc:	4f 4f       	sbci	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	0e c0       	rjmp	.+28     	; 0x7ee <__fixsfsi+0x9c>
     7d2:	20 e0       	ldi	r18, 0x00	; 0
     7d4:	30 e0       	ldi	r19, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	09 c0       	rjmp	.+18     	; 0x7ee <__fixsfsi+0x9c>
     7dc:	2f ef       	ldi	r18, 0xFF	; 255
     7de:	3f ef       	ldi	r19, 0xFF	; 255
     7e0:	4f ef       	ldi	r20, 0xFF	; 255
     7e2:	5f e7       	ldi	r21, 0x7F	; 127
     7e4:	04 c0       	rjmp	.+8      	; 0x7ee <__fixsfsi+0x9c>
     7e6:	20 e0       	ldi	r18, 0x00	; 0
     7e8:	30 e0       	ldi	r19, 0x00	; 0
     7ea:	40 e0       	ldi	r20, 0x00	; 0
     7ec:	50 e8       	ldi	r21, 0x80	; 128
     7ee:	b9 01       	movw	r22, r18
     7f0:	ca 01       	movw	r24, r20
     7f2:	2c 96       	adiw	r28, 0x0c	; 12
     7f4:	e2 e0       	ldi	r30, 0x02	; 2
     7f6:	0c 94 3f 11 	jmp	0x227e	; 0x227e <__epilogue_restores__+0x20>

000007fa <__pack_f>:
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
     802:	1f 93       	push	r17
     804:	fc 01       	movw	r30, r24
     806:	e4 80       	ldd	r14, Z+4	; 0x04
     808:	f5 80       	ldd	r15, Z+5	; 0x05
     80a:	06 81       	ldd	r16, Z+6	; 0x06
     80c:	17 81       	ldd	r17, Z+7	; 0x07
     80e:	d1 80       	ldd	r13, Z+1	; 0x01
     810:	80 81       	ld	r24, Z
     812:	82 30       	cpi	r24, 0x02	; 2
     814:	48 f4       	brcc	.+18     	; 0x828 <__pack_f+0x2e>
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	a0 e1       	ldi	r26, 0x10	; 16
     81c:	b0 e0       	ldi	r27, 0x00	; 0
     81e:	e8 2a       	or	r14, r24
     820:	f9 2a       	or	r15, r25
     822:	0a 2b       	or	r16, r26
     824:	1b 2b       	or	r17, r27
     826:	a5 c0       	rjmp	.+330    	; 0x972 <__stack+0x113>
     828:	84 30       	cpi	r24, 0x04	; 4
     82a:	09 f4       	brne	.+2      	; 0x82e <__pack_f+0x34>
     82c:	9f c0       	rjmp	.+318    	; 0x96c <__stack+0x10d>
     82e:	82 30       	cpi	r24, 0x02	; 2
     830:	21 f4       	brne	.+8      	; 0x83a <__pack_f+0x40>
     832:	ee 24       	eor	r14, r14
     834:	ff 24       	eor	r15, r15
     836:	87 01       	movw	r16, r14
     838:	05 c0       	rjmp	.+10     	; 0x844 <__pack_f+0x4a>
     83a:	e1 14       	cp	r14, r1
     83c:	f1 04       	cpc	r15, r1
     83e:	01 05       	cpc	r16, r1
     840:	11 05       	cpc	r17, r1
     842:	19 f4       	brne	.+6      	; 0x84a <__pack_f+0x50>
     844:	e0 e0       	ldi	r30, 0x00	; 0
     846:	f0 e0       	ldi	r31, 0x00	; 0
     848:	96 c0       	rjmp	.+300    	; 0x976 <__stack+0x117>
     84a:	62 81       	ldd	r22, Z+2	; 0x02
     84c:	73 81       	ldd	r23, Z+3	; 0x03
     84e:	9f ef       	ldi	r25, 0xFF	; 255
     850:	62 38       	cpi	r22, 0x82	; 130
     852:	79 07       	cpc	r23, r25
     854:	0c f0       	brlt	.+2      	; 0x858 <__pack_f+0x5e>
     856:	5b c0       	rjmp	.+182    	; 0x90e <__stack+0xaf>
     858:	22 e8       	ldi	r18, 0x82	; 130
     85a:	3f ef       	ldi	r19, 0xFF	; 255
     85c:	26 1b       	sub	r18, r22
     85e:	37 0b       	sbc	r19, r23
     860:	2a 31       	cpi	r18, 0x1A	; 26
     862:	31 05       	cpc	r19, r1
     864:	2c f0       	brlt	.+10     	; 0x870 <__stack+0x11>
     866:	20 e0       	ldi	r18, 0x00	; 0
     868:	30 e0       	ldi	r19, 0x00	; 0
     86a:	40 e0       	ldi	r20, 0x00	; 0
     86c:	50 e0       	ldi	r21, 0x00	; 0
     86e:	2a c0       	rjmp	.+84     	; 0x8c4 <__stack+0x65>
     870:	b8 01       	movw	r22, r16
     872:	a7 01       	movw	r20, r14
     874:	02 2e       	mov	r0, r18
     876:	04 c0       	rjmp	.+8      	; 0x880 <__stack+0x21>
     878:	76 95       	lsr	r23
     87a:	67 95       	ror	r22
     87c:	57 95       	ror	r21
     87e:	47 95       	ror	r20
     880:	0a 94       	dec	r0
     882:	d2 f7       	brpl	.-12     	; 0x878 <__stack+0x19>
     884:	81 e0       	ldi	r24, 0x01	; 1
     886:	90 e0       	ldi	r25, 0x00	; 0
     888:	a0 e0       	ldi	r26, 0x00	; 0
     88a:	b0 e0       	ldi	r27, 0x00	; 0
     88c:	04 c0       	rjmp	.+8      	; 0x896 <__stack+0x37>
     88e:	88 0f       	add	r24, r24
     890:	99 1f       	adc	r25, r25
     892:	aa 1f       	adc	r26, r26
     894:	bb 1f       	adc	r27, r27
     896:	2a 95       	dec	r18
     898:	d2 f7       	brpl	.-12     	; 0x88e <__stack+0x2f>
     89a:	01 97       	sbiw	r24, 0x01	; 1
     89c:	a1 09       	sbc	r26, r1
     89e:	b1 09       	sbc	r27, r1
     8a0:	8e 21       	and	r24, r14
     8a2:	9f 21       	and	r25, r15
     8a4:	a0 23       	and	r26, r16
     8a6:	b1 23       	and	r27, r17
     8a8:	00 97       	sbiw	r24, 0x00	; 0
     8aa:	a1 05       	cpc	r26, r1
     8ac:	b1 05       	cpc	r27, r1
     8ae:	21 f0       	breq	.+8      	; 0x8b8 <__stack+0x59>
     8b0:	81 e0       	ldi	r24, 0x01	; 1
     8b2:	90 e0       	ldi	r25, 0x00	; 0
     8b4:	a0 e0       	ldi	r26, 0x00	; 0
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	9a 01       	movw	r18, r20
     8ba:	ab 01       	movw	r20, r22
     8bc:	28 2b       	or	r18, r24
     8be:	39 2b       	or	r19, r25
     8c0:	4a 2b       	or	r20, r26
     8c2:	5b 2b       	or	r21, r27
     8c4:	da 01       	movw	r26, r20
     8c6:	c9 01       	movw	r24, r18
     8c8:	8f 77       	andi	r24, 0x7F	; 127
     8ca:	90 70       	andi	r25, 0x00	; 0
     8cc:	a0 70       	andi	r26, 0x00	; 0
     8ce:	b0 70       	andi	r27, 0x00	; 0
     8d0:	80 34       	cpi	r24, 0x40	; 64
     8d2:	91 05       	cpc	r25, r1
     8d4:	a1 05       	cpc	r26, r1
     8d6:	b1 05       	cpc	r27, r1
     8d8:	39 f4       	brne	.+14     	; 0x8e8 <__stack+0x89>
     8da:	27 ff       	sbrs	r18, 7
     8dc:	09 c0       	rjmp	.+18     	; 0x8f0 <__stack+0x91>
     8de:	20 5c       	subi	r18, 0xC0	; 192
     8e0:	3f 4f       	sbci	r19, 0xFF	; 255
     8e2:	4f 4f       	sbci	r20, 0xFF	; 255
     8e4:	5f 4f       	sbci	r21, 0xFF	; 255
     8e6:	04 c0       	rjmp	.+8      	; 0x8f0 <__stack+0x91>
     8e8:	21 5c       	subi	r18, 0xC1	; 193
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	4f 4f       	sbci	r20, 0xFF	; 255
     8ee:	5f 4f       	sbci	r21, 0xFF	; 255
     8f0:	e0 e0       	ldi	r30, 0x00	; 0
     8f2:	f0 e0       	ldi	r31, 0x00	; 0
     8f4:	20 30       	cpi	r18, 0x00	; 0
     8f6:	a0 e0       	ldi	r26, 0x00	; 0
     8f8:	3a 07       	cpc	r19, r26
     8fa:	a0 e0       	ldi	r26, 0x00	; 0
     8fc:	4a 07       	cpc	r20, r26
     8fe:	a0 e4       	ldi	r26, 0x40	; 64
     900:	5a 07       	cpc	r21, r26
     902:	10 f0       	brcs	.+4      	; 0x908 <__stack+0xa9>
     904:	e1 e0       	ldi	r30, 0x01	; 1
     906:	f0 e0       	ldi	r31, 0x00	; 0
     908:	79 01       	movw	r14, r18
     90a:	8a 01       	movw	r16, r20
     90c:	27 c0       	rjmp	.+78     	; 0x95c <__stack+0xfd>
     90e:	60 38       	cpi	r22, 0x80	; 128
     910:	71 05       	cpc	r23, r1
     912:	64 f5       	brge	.+88     	; 0x96c <__stack+0x10d>
     914:	fb 01       	movw	r30, r22
     916:	e1 58       	subi	r30, 0x81	; 129
     918:	ff 4f       	sbci	r31, 0xFF	; 255
     91a:	d8 01       	movw	r26, r16
     91c:	c7 01       	movw	r24, r14
     91e:	8f 77       	andi	r24, 0x7F	; 127
     920:	90 70       	andi	r25, 0x00	; 0
     922:	a0 70       	andi	r26, 0x00	; 0
     924:	b0 70       	andi	r27, 0x00	; 0
     926:	80 34       	cpi	r24, 0x40	; 64
     928:	91 05       	cpc	r25, r1
     92a:	a1 05       	cpc	r26, r1
     92c:	b1 05       	cpc	r27, r1
     92e:	39 f4       	brne	.+14     	; 0x93e <__stack+0xdf>
     930:	e7 fe       	sbrs	r14, 7
     932:	0d c0       	rjmp	.+26     	; 0x94e <__stack+0xef>
     934:	80 e4       	ldi	r24, 0x40	; 64
     936:	90 e0       	ldi	r25, 0x00	; 0
     938:	a0 e0       	ldi	r26, 0x00	; 0
     93a:	b0 e0       	ldi	r27, 0x00	; 0
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__stack+0xe7>
     93e:	8f e3       	ldi	r24, 0x3F	; 63
     940:	90 e0       	ldi	r25, 0x00	; 0
     942:	a0 e0       	ldi	r26, 0x00	; 0
     944:	b0 e0       	ldi	r27, 0x00	; 0
     946:	e8 0e       	add	r14, r24
     948:	f9 1e       	adc	r15, r25
     94a:	0a 1f       	adc	r16, r26
     94c:	1b 1f       	adc	r17, r27
     94e:	17 ff       	sbrs	r17, 7
     950:	05 c0       	rjmp	.+10     	; 0x95c <__stack+0xfd>
     952:	16 95       	lsr	r17
     954:	07 95       	ror	r16
     956:	f7 94       	ror	r15
     958:	e7 94       	ror	r14
     95a:	31 96       	adiw	r30, 0x01	; 1
     95c:	87 e0       	ldi	r24, 0x07	; 7
     95e:	16 95       	lsr	r17
     960:	07 95       	ror	r16
     962:	f7 94       	ror	r15
     964:	e7 94       	ror	r14
     966:	8a 95       	dec	r24
     968:	d1 f7       	brne	.-12     	; 0x95e <__stack+0xff>
     96a:	05 c0       	rjmp	.+10     	; 0x976 <__stack+0x117>
     96c:	ee 24       	eor	r14, r14
     96e:	ff 24       	eor	r15, r15
     970:	87 01       	movw	r16, r14
     972:	ef ef       	ldi	r30, 0xFF	; 255
     974:	f0 e0       	ldi	r31, 0x00	; 0
     976:	6e 2f       	mov	r22, r30
     978:	67 95       	ror	r22
     97a:	66 27       	eor	r22, r22
     97c:	67 95       	ror	r22
     97e:	90 2f       	mov	r25, r16
     980:	9f 77       	andi	r25, 0x7F	; 127
     982:	d7 94       	ror	r13
     984:	dd 24       	eor	r13, r13
     986:	d7 94       	ror	r13
     988:	8e 2f       	mov	r24, r30
     98a:	86 95       	lsr	r24
     98c:	49 2f       	mov	r20, r25
     98e:	46 2b       	or	r20, r22
     990:	58 2f       	mov	r21, r24
     992:	5d 29       	or	r21, r13
     994:	b7 01       	movw	r22, r14
     996:	ca 01       	movw	r24, r20
     998:	1f 91       	pop	r17
     99a:	0f 91       	pop	r16
     99c:	ff 90       	pop	r15
     99e:	ef 90       	pop	r14
     9a0:	df 90       	pop	r13
     9a2:	08 95       	ret

000009a4 <__unpack_f>:
     9a4:	fc 01       	movw	r30, r24
     9a6:	db 01       	movw	r26, r22
     9a8:	40 81       	ld	r20, Z
     9aa:	51 81       	ldd	r21, Z+1	; 0x01
     9ac:	22 81       	ldd	r18, Z+2	; 0x02
     9ae:	62 2f       	mov	r22, r18
     9b0:	6f 77       	andi	r22, 0x7F	; 127
     9b2:	70 e0       	ldi	r23, 0x00	; 0
     9b4:	22 1f       	adc	r18, r18
     9b6:	22 27       	eor	r18, r18
     9b8:	22 1f       	adc	r18, r18
     9ba:	93 81       	ldd	r25, Z+3	; 0x03
     9bc:	89 2f       	mov	r24, r25
     9be:	88 0f       	add	r24, r24
     9c0:	82 2b       	or	r24, r18
     9c2:	28 2f       	mov	r18, r24
     9c4:	30 e0       	ldi	r19, 0x00	; 0
     9c6:	99 1f       	adc	r25, r25
     9c8:	99 27       	eor	r25, r25
     9ca:	99 1f       	adc	r25, r25
     9cc:	11 96       	adiw	r26, 0x01	; 1
     9ce:	9c 93       	st	X, r25
     9d0:	11 97       	sbiw	r26, 0x01	; 1
     9d2:	21 15       	cp	r18, r1
     9d4:	31 05       	cpc	r19, r1
     9d6:	a9 f5       	brne	.+106    	; 0xa42 <__unpack_f+0x9e>
     9d8:	41 15       	cp	r20, r1
     9da:	51 05       	cpc	r21, r1
     9dc:	61 05       	cpc	r22, r1
     9de:	71 05       	cpc	r23, r1
     9e0:	11 f4       	brne	.+4      	; 0x9e6 <__unpack_f+0x42>
     9e2:	82 e0       	ldi	r24, 0x02	; 2
     9e4:	37 c0       	rjmp	.+110    	; 0xa54 <__unpack_f+0xb0>
     9e6:	82 e8       	ldi	r24, 0x82	; 130
     9e8:	9f ef       	ldi	r25, 0xFF	; 255
     9ea:	13 96       	adiw	r26, 0x03	; 3
     9ec:	9c 93       	st	X, r25
     9ee:	8e 93       	st	-X, r24
     9f0:	12 97       	sbiw	r26, 0x02	; 2
     9f2:	9a 01       	movw	r18, r20
     9f4:	ab 01       	movw	r20, r22
     9f6:	67 e0       	ldi	r22, 0x07	; 7
     9f8:	22 0f       	add	r18, r18
     9fa:	33 1f       	adc	r19, r19
     9fc:	44 1f       	adc	r20, r20
     9fe:	55 1f       	adc	r21, r21
     a00:	6a 95       	dec	r22
     a02:	d1 f7       	brne	.-12     	; 0x9f8 <__unpack_f+0x54>
     a04:	83 e0       	ldi	r24, 0x03	; 3
     a06:	8c 93       	st	X, r24
     a08:	0d c0       	rjmp	.+26     	; 0xa24 <__unpack_f+0x80>
     a0a:	22 0f       	add	r18, r18
     a0c:	33 1f       	adc	r19, r19
     a0e:	44 1f       	adc	r20, r20
     a10:	55 1f       	adc	r21, r21
     a12:	12 96       	adiw	r26, 0x02	; 2
     a14:	8d 91       	ld	r24, X+
     a16:	9c 91       	ld	r25, X
     a18:	13 97       	sbiw	r26, 0x03	; 3
     a1a:	01 97       	sbiw	r24, 0x01	; 1
     a1c:	13 96       	adiw	r26, 0x03	; 3
     a1e:	9c 93       	st	X, r25
     a20:	8e 93       	st	-X, r24
     a22:	12 97       	sbiw	r26, 0x02	; 2
     a24:	20 30       	cpi	r18, 0x00	; 0
     a26:	80 e0       	ldi	r24, 0x00	; 0
     a28:	38 07       	cpc	r19, r24
     a2a:	80 e0       	ldi	r24, 0x00	; 0
     a2c:	48 07       	cpc	r20, r24
     a2e:	80 e4       	ldi	r24, 0x40	; 64
     a30:	58 07       	cpc	r21, r24
     a32:	58 f3       	brcs	.-42     	; 0xa0a <__unpack_f+0x66>
     a34:	14 96       	adiw	r26, 0x04	; 4
     a36:	2d 93       	st	X+, r18
     a38:	3d 93       	st	X+, r19
     a3a:	4d 93       	st	X+, r20
     a3c:	5c 93       	st	X, r21
     a3e:	17 97       	sbiw	r26, 0x07	; 7
     a40:	08 95       	ret
     a42:	2f 3f       	cpi	r18, 0xFF	; 255
     a44:	31 05       	cpc	r19, r1
     a46:	79 f4       	brne	.+30     	; 0xa66 <__unpack_f+0xc2>
     a48:	41 15       	cp	r20, r1
     a4a:	51 05       	cpc	r21, r1
     a4c:	61 05       	cpc	r22, r1
     a4e:	71 05       	cpc	r23, r1
     a50:	19 f4       	brne	.+6      	; 0xa58 <__unpack_f+0xb4>
     a52:	84 e0       	ldi	r24, 0x04	; 4
     a54:	8c 93       	st	X, r24
     a56:	08 95       	ret
     a58:	64 ff       	sbrs	r22, 4
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <__unpack_f+0xbe>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	8c 93       	st	X, r24
     a60:	12 c0       	rjmp	.+36     	; 0xa86 <__unpack_f+0xe2>
     a62:	1c 92       	st	X, r1
     a64:	10 c0       	rjmp	.+32     	; 0xa86 <__unpack_f+0xe2>
     a66:	2f 57       	subi	r18, 0x7F	; 127
     a68:	30 40       	sbci	r19, 0x00	; 0
     a6a:	13 96       	adiw	r26, 0x03	; 3
     a6c:	3c 93       	st	X, r19
     a6e:	2e 93       	st	-X, r18
     a70:	12 97       	sbiw	r26, 0x02	; 2
     a72:	83 e0       	ldi	r24, 0x03	; 3
     a74:	8c 93       	st	X, r24
     a76:	87 e0       	ldi	r24, 0x07	; 7
     a78:	44 0f       	add	r20, r20
     a7a:	55 1f       	adc	r21, r21
     a7c:	66 1f       	adc	r22, r22
     a7e:	77 1f       	adc	r23, r23
     a80:	8a 95       	dec	r24
     a82:	d1 f7       	brne	.-12     	; 0xa78 <__unpack_f+0xd4>
     a84:	70 64       	ori	r23, 0x40	; 64
     a86:	14 96       	adiw	r26, 0x04	; 4
     a88:	4d 93       	st	X+, r20
     a8a:	5d 93       	st	X+, r21
     a8c:	6d 93       	st	X+, r22
     a8e:	7c 93       	st	X, r23
     a90:	17 97       	sbiw	r26, 0x07	; 7
     a92:	08 95       	ret

00000a94 <__fpcmp_parts_f>:
     a94:	1f 93       	push	r17
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
     a9a:	9c 91       	ld	r25, X
     a9c:	92 30       	cpi	r25, 0x02	; 2
     a9e:	08 f4       	brcc	.+2      	; 0xaa2 <__fpcmp_parts_f+0xe>
     aa0:	47 c0       	rjmp	.+142    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aa2:	80 81       	ld	r24, Z
     aa4:	82 30       	cpi	r24, 0x02	; 2
     aa6:	08 f4       	brcc	.+2      	; 0xaaa <__fpcmp_parts_f+0x16>
     aa8:	43 c0       	rjmp	.+134    	; 0xb30 <__fpcmp_parts_f+0x9c>
     aaa:	94 30       	cpi	r25, 0x04	; 4
     aac:	51 f4       	brne	.+20     	; 0xac2 <__fpcmp_parts_f+0x2e>
     aae:	11 96       	adiw	r26, 0x01	; 1
     ab0:	1c 91       	ld	r17, X
     ab2:	84 30       	cpi	r24, 0x04	; 4
     ab4:	99 f5       	brne	.+102    	; 0xb1c <__fpcmp_parts_f+0x88>
     ab6:	81 81       	ldd	r24, Z+1	; 0x01
     ab8:	68 2f       	mov	r22, r24
     aba:	70 e0       	ldi	r23, 0x00	; 0
     abc:	61 1b       	sub	r22, r17
     abe:	71 09       	sbc	r23, r1
     ac0:	3f c0       	rjmp	.+126    	; 0xb40 <__fpcmp_parts_f+0xac>
     ac2:	84 30       	cpi	r24, 0x04	; 4
     ac4:	21 f0       	breq	.+8      	; 0xace <__fpcmp_parts_f+0x3a>
     ac6:	92 30       	cpi	r25, 0x02	; 2
     ac8:	31 f4       	brne	.+12     	; 0xad6 <__fpcmp_parts_f+0x42>
     aca:	82 30       	cpi	r24, 0x02	; 2
     acc:	b9 f1       	breq	.+110    	; 0xb3c <__fpcmp_parts_f+0xa8>
     ace:	81 81       	ldd	r24, Z+1	; 0x01
     ad0:	88 23       	and	r24, r24
     ad2:	89 f1       	breq	.+98     	; 0xb36 <__fpcmp_parts_f+0xa2>
     ad4:	2d c0       	rjmp	.+90     	; 0xb30 <__fpcmp_parts_f+0x9c>
     ad6:	11 96       	adiw	r26, 0x01	; 1
     ad8:	1c 91       	ld	r17, X
     ada:	11 97       	sbiw	r26, 0x01	; 1
     adc:	82 30       	cpi	r24, 0x02	; 2
     ade:	f1 f0       	breq	.+60     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae0:	81 81       	ldd	r24, Z+1	; 0x01
     ae2:	18 17       	cp	r17, r24
     ae4:	d9 f4       	brne	.+54     	; 0xb1c <__fpcmp_parts_f+0x88>
     ae6:	12 96       	adiw	r26, 0x02	; 2
     ae8:	2d 91       	ld	r18, X+
     aea:	3c 91       	ld	r19, X
     aec:	13 97       	sbiw	r26, 0x03	; 3
     aee:	82 81       	ldd	r24, Z+2	; 0x02
     af0:	93 81       	ldd	r25, Z+3	; 0x03
     af2:	82 17       	cp	r24, r18
     af4:	93 07       	cpc	r25, r19
     af6:	94 f0       	brlt	.+36     	; 0xb1c <__fpcmp_parts_f+0x88>
     af8:	28 17       	cp	r18, r24
     afa:	39 07       	cpc	r19, r25
     afc:	bc f0       	brlt	.+46     	; 0xb2c <__fpcmp_parts_f+0x98>
     afe:	14 96       	adiw	r26, 0x04	; 4
     b00:	8d 91       	ld	r24, X+
     b02:	9d 91       	ld	r25, X+
     b04:	0d 90       	ld	r0, X+
     b06:	bc 91       	ld	r27, X
     b08:	a0 2d       	mov	r26, r0
     b0a:	24 81       	ldd	r18, Z+4	; 0x04
     b0c:	35 81       	ldd	r19, Z+5	; 0x05
     b0e:	46 81       	ldd	r20, Z+6	; 0x06
     b10:	57 81       	ldd	r21, Z+7	; 0x07
     b12:	28 17       	cp	r18, r24
     b14:	39 07       	cpc	r19, r25
     b16:	4a 07       	cpc	r20, r26
     b18:	5b 07       	cpc	r21, r27
     b1a:	18 f4       	brcc	.+6      	; 0xb22 <__fpcmp_parts_f+0x8e>
     b1c:	11 23       	and	r17, r17
     b1e:	41 f0       	breq	.+16     	; 0xb30 <__fpcmp_parts_f+0x9c>
     b20:	0a c0       	rjmp	.+20     	; 0xb36 <__fpcmp_parts_f+0xa2>
     b22:	82 17       	cp	r24, r18
     b24:	93 07       	cpc	r25, r19
     b26:	a4 07       	cpc	r26, r20
     b28:	b5 07       	cpc	r27, r21
     b2a:	40 f4       	brcc	.+16     	; 0xb3c <__fpcmp_parts_f+0xa8>
     b2c:	11 23       	and	r17, r17
     b2e:	19 f0       	breq	.+6      	; 0xb36 <__fpcmp_parts_f+0xa2>
     b30:	61 e0       	ldi	r22, 0x01	; 1
     b32:	70 e0       	ldi	r23, 0x00	; 0
     b34:	05 c0       	rjmp	.+10     	; 0xb40 <__fpcmp_parts_f+0xac>
     b36:	6f ef       	ldi	r22, 0xFF	; 255
     b38:	7f ef       	ldi	r23, 0xFF	; 255
     b3a:	02 c0       	rjmp	.+4      	; 0xb40 <__fpcmp_parts_f+0xac>
     b3c:	60 e0       	ldi	r22, 0x00	; 0
     b3e:	70 e0       	ldi	r23, 0x00	; 0
     b40:	cb 01       	movw	r24, r22
     b42:	1f 91       	pop	r17
     b44:	08 95       	ret

00000b46 <DcMotor_Init>:
#include "Timer0.h"
#include "gpio.h"
#include "DC_Motor.h"


 void DcMotor_Init(void){
     b46:	df 93       	push	r29
     b48:	cf 93       	push	r28
     b4a:	cd b7       	in	r28, 0x3d	; 61
     b4c:	de b7       	in	r29, 0x3e	; 62

	/* Configure Pin PC0 And PC1 As Output Pins For IN1&IN2 For H-Bridge */
	GPIO_setupPinDirection(DC_Motor_EN_Port, DC_Motor_EN1_Pin, PIN_OUTPUT);
     b4e:	81 e0       	ldi	r24, 0x01	; 1
     b50:	63 e0       	ldi	r22, 0x03	; 3
     b52:	41 e0       	ldi	r20, 0x01	; 1
     b54:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_Motor_IN_Port, DC_Motor_IN1_Pin, PIN_OUTPUT );
     b58:	83 e0       	ldi	r24, 0x03	; 3
     b5a:	66 e0       	ldi	r22, 0x06	; 6
     b5c:	41 e0       	ldi	r20, 0x01	; 1
     b5e:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>
	GPIO_setupPinDirection(DC_Motor_IN_Port, DC_Motor_IN2_Pin, PIN_OUTPUT );
     b62:	83 e0       	ldi	r24, 0x03	; 3
     b64:	67 e0       	ldi	r22, 0x07	; 7
     b66:	41 e0       	ldi	r20, 0x01	; 1
     b68:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>

	/* Motor is Stop At The Beginning By Put Logic Low For IN1&IN2 */
	GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN1_Pin, LOGIC_LOW) ;
     b6c:	83 e0       	ldi	r24, 0x03	; 3
     b6e:	66 e0       	ldi	r22, 0x06	; 6
     b70:	40 e0       	ldi	r20, 0x00	; 0
     b72:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN2_Pin, LOGIC_LOW) ;
     b76:	83 e0       	ldi	r24, 0x03	; 3
     b78:	67 e0       	ldi	r22, 0x07	; 7
     b7a:	40 e0       	ldi	r20, 0x00	; 0
     b7c:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>

 }
     b80:	cf 91       	pop	r28
     b82:	df 91       	pop	r29
     b84:	08 95       	ret

00000b86 <DcMotor_Rotate>:

 void DcMotor_Rotate(DcMotor_State state,uint8 speed){
     b86:	df 93       	push	r29
     b88:	cf 93       	push	r28
     b8a:	00 d0       	rcall	.+0      	; 0xb8c <DcMotor_Rotate+0x6>
     b8c:	00 d0       	rcall	.+0      	; 0xb8e <DcMotor_Rotate+0x8>
     b8e:	cd b7       	in	r28, 0x3d	; 61
     b90:	de b7       	in	r29, 0x3e	; 62
     b92:	89 83       	std	Y+1, r24	; 0x01
     b94:	6a 83       	std	Y+2, r22	; 0x02

	 /*Call PWM signal starter with speed 0->100 as a duty cycle*/
	 PWM_Timer0_Start(speed);
     b96:	8a 81       	ldd	r24, Y+2	; 0x02
     b98:	0e 94 18 06 	call	0xc30	; 0xc30 <PWM_Timer0_Start>

	 /*Choose The State of Motor*/
	 switch (state){
     b9c:	89 81       	ldd	r24, Y+1	; 0x01
     b9e:	28 2f       	mov	r18, r24
     ba0:	30 e0       	ldi	r19, 0x00	; 0
     ba2:	3c 83       	std	Y+4, r19	; 0x04
     ba4:	2b 83       	std	Y+3, r18	; 0x03
     ba6:	8b 81       	ldd	r24, Y+3	; 0x03
     ba8:	9c 81       	ldd	r25, Y+4	; 0x04
     baa:	81 30       	cpi	r24, 0x01	; 1
     bac:	91 05       	cpc	r25, r1
     bae:	21 f1       	breq	.+72     	; 0xbf8 <DcMotor_Rotate+0x72>
     bb0:	2b 81       	ldd	r18, Y+3	; 0x03
     bb2:	3c 81       	ldd	r19, Y+4	; 0x04
     bb4:	22 30       	cpi	r18, 0x02	; 2
     bb6:	31 05       	cpc	r19, r1
     bb8:	a1 f0       	breq	.+40     	; 0xbe2 <DcMotor_Rotate+0x5c>
     bba:	8b 81       	ldd	r24, Y+3	; 0x03
     bbc:	9c 81       	ldd	r25, Y+4	; 0x04
     bbe:	00 97       	sbiw	r24, 0x00	; 0
     bc0:	31 f5       	brne	.+76     	; 0xc0e <DcMotor_Rotate+0x88>

	 	 case stop : /*IN1=LOW & IN2=LOW*/
	 		 	 	 GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN1_Pin, LOGIC_LOW) ;
     bc2:	83 e0       	ldi	r24, 0x03	; 3
     bc4:	66 e0       	ldi	r22, 0x06	; 6
     bc6:	40 e0       	ldi	r20, 0x00	; 0
     bc8:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	 	 GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN2_Pin, LOGIC_LOW) ;
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	67 e0       	ldi	r22, 0x07	; 7
     bd0:	40 e0       	ldi	r20, 0x00	; 0
     bd2:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	 	 GPIO_writePin(DC_Motor_EN_Port, DC_Motor_EN1_Pin, LOGIC_LOW);
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	63 e0       	ldi	r22, 0x03	; 3
     bda:	40 e0       	ldi	r20, 0x00	; 0
     bdc:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
     be0:	20 c0       	rjmp	.+64     	; 0xc22 <DcMotor_Rotate+0x9c>
	 	 	 	 	 break;

	 	 case CW : /*IN1=LOW & IN2=HIGH*/
	 		 	   GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN1_Pin, LOGIC_HIGH) ;
     be2:	83 e0       	ldi	r24, 0x03	; 3
     be4:	66 e0       	ldi	r22, 0x06	; 6
     be6:	41 e0       	ldi	r20, 0x01	; 1
     be8:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	   GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN2_Pin, LOGIC_LOW) ;
     bec:	83 e0       	ldi	r24, 0x03	; 3
     bee:	67 e0       	ldi	r22, 0x07	; 7
     bf0:	40 e0       	ldi	r20, 0x00	; 0
     bf2:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
     bf6:	15 c0       	rjmp	.+42     	; 0xc22 <DcMotor_Rotate+0x9c>
	 	 	 	   break;

	 	 case CCW : /*IN1=HIGH & IN2=LOW*/
	 		 	    GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN1_Pin, LOGIC_LOW) ;
     bf8:	83 e0       	ldi	r24, 0x03	; 3
     bfa:	66 e0       	ldi	r22, 0x06	; 6
     bfc:	40 e0       	ldi	r20, 0x00	; 0
     bfe:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	 	GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN2_Pin, LOGIC_HIGH) ;
     c02:	83 e0       	ldi	r24, 0x03	; 3
     c04:	67 e0       	ldi	r22, 0x07	; 7
     c06:	41 e0       	ldi	r20, 0x01	; 1
     c08:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
     c0c:	0a c0       	rjmp	.+20     	; 0xc22 <DcMotor_Rotate+0x9c>
	 	 	 	 	break;

	 	 default : /*The Motor is Stop As A Default */
	 		 	   GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN1_Pin, LOGIC_LOW) ;
     c0e:	83 e0       	ldi	r24, 0x03	; 3
     c10:	66 e0       	ldi	r22, 0x06	; 6
     c12:	40 e0       	ldi	r20, 0x00	; 0
     c14:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	   GPIO_writePin(DC_Motor_IN_Port, DC_Motor_IN2_Pin, LOGIC_LOW) ;
     c18:	83 e0       	ldi	r24, 0x03	; 3
     c1a:	67 e0       	ldi	r22, 0x07	; 7
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
	 	 	 	   break;
	 }


 }
     c22:	0f 90       	pop	r0
     c24:	0f 90       	pop	r0
     c26:	0f 90       	pop	r0
     c28:	0f 90       	pop	r0
     c2a:	cf 91       	pop	r28
     c2c:	df 91       	pop	r29
     c2e:	08 95       	ret

00000c30 <PWM_Timer0_Start>:
 * F_PWM=(F_CPU)/(256*N) = (10^6)/(256*8) = 500Hz
 * Duty Cycle can be changed by updating the value
 * in The Compare Register
 */
void PWM_Timer0_Start(uint8 duty_cycle_precentage)
{
     c30:	df 93       	push	r29
     c32:	cf 93       	push	r28
     c34:	0f 92       	push	r0
     c36:	cd b7       	in	r28, 0x3d	; 61
     c38:	de b7       	in	r29, 0x3e	; 62
     c3a:	89 83       	std	Y+1, r24	; 0x01
	/* Set Timer Initial Value to 0*/
	TCNT0 = 0;
     c3c:	e2 e5       	ldi	r30, 0x52	; 82
     c3e:	f0 e0       	ldi	r31, 0x00	; 0
     c40:	10 82       	st	Z, r1
	/*Set Compare Value*/
	OCR0  = ( Dudy_Cycle(dudy_cycle_precentage) ) ;
     c42:	ec e5       	ldi	r30, 0x5C	; 92
     c44:	f0 e0       	ldi	r31, 0x00	; 0
     c46:	89 81       	ldd	r24, Y+1	; 0x01
     c48:	48 2f       	mov	r20, r24
     c4a:	50 e0       	ldi	r21, 0x00	; 0
     c4c:	ca 01       	movw	r24, r20
     c4e:	9c 01       	movw	r18, r24
     c50:	22 0f       	add	r18, r18
     c52:	33 1f       	adc	r19, r19
     c54:	c9 01       	movw	r24, r18
     c56:	96 95       	lsr	r25
     c58:	98 2f       	mov	r25, r24
     c5a:	88 27       	eor	r24, r24
     c5c:	97 95       	ror	r25
     c5e:	87 95       	ror	r24
     c60:	82 1b       	sub	r24, r18
     c62:	93 0b       	sbc	r25, r19
     c64:	84 0f       	add	r24, r20
     c66:	95 1f       	adc	r25, r21
     c68:	24 e6       	ldi	r18, 0x64	; 100
     c6a:	30 e0       	ldi	r19, 0x00	; 0
     c6c:	b9 01       	movw	r22, r18
     c6e:	0e 94 dd 10 	call	0x21ba	; 0x21ba <__udivmodhi4>
     c72:	cb 01       	movw	r24, r22
     c74:	80 83       	st	Z, r24
	/*Configure PB3/OC0 as output pin -> pin where the PWM signal is generated */
	GPIO_setupPinDirection(PWM_Signal_Output_Port, PWM_Signal_Output_Pin, PIN_OUTPUT );
     c76:	81 e0       	ldi	r24, 0x01	; 1
     c78:	63 e0       	ldi	r22, 0x03	; 3
     c7a:	41 e0       	ldi	r20, 0x01	; 1
     c7c:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>
	/* Configure timer control register :
	 * 1. Fast PWM mode FOC0=0 & WGM01=1 & WGM00=1
	 * 2. Clear OC0 when match occurs (non inverted mode) COM00=0 & COM01=1
	 * 3. clock = F_CPU/8 CS00=0 CS01=1 CS02=0
	 */
	TCCR0 = (1<<WGM00) | (1<<WGM01) | (1<<COM01) | (1<<CS01);
     c80:	e3 e5       	ldi	r30, 0x53	; 83
     c82:	f0 e0       	ldi	r31, 0x00	; 0
     c84:	8a e6       	ldi	r24, 0x6A	; 106
     c86:	80 83       	st	Z, r24
}
     c88:	0f 90       	pop	r0
     c8a:	cf 91       	pop	r28
     c8c:	df 91       	pop	r29
     c8e:	08 95       	ret

00000c90 <Buzzer_init>:
#include "buzzer.h"
#include <avr/io.h>
#include "gpio.h"
#include "common_macros.h"

void Buzzer_init(){
     c90:	df 93       	push	r29
     c92:	cf 93       	push	r28
     c94:	cd b7       	in	r28, 0x3d	; 61
     c96:	de b7       	in	r29, 0x3e	; 62

	GPIO_setupPinDirection(buzzerPORT_ID,buzzerPIN_ID, PIN_OUTPUT);
     c98:	82 e0       	ldi	r24, 0x02	; 2
     c9a:	67 e0       	ldi	r22, 0x07	; 7
     c9c:	41 e0       	ldi	r20, 0x01	; 1
     c9e:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>
	GPIO_writePin(buzzerPORT_ID,buzzerPIN_ID, LOGIC_LOW);
     ca2:	82 e0       	ldi	r24, 0x02	; 2
     ca4:	67 e0       	ldi	r22, 0x07	; 7
     ca6:	40 e0       	ldi	r20, 0x00	; 0
     ca8:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>

}
     cac:	cf 91       	pop	r28
     cae:	df 91       	pop	r29
     cb0:	08 95       	ret

00000cb2 <Buzzer_on>:

void Buzzer_on(void){
     cb2:	df 93       	push	r29
     cb4:	cf 93       	push	r28
     cb6:	cd b7       	in	r28, 0x3d	; 61
     cb8:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(buzzerPORT_ID,buzzerPIN_ID, LOGIC_HIGH);
     cba:	82 e0       	ldi	r24, 0x02	; 2
     cbc:	67 e0       	ldi	r22, 0x07	; 7
     cbe:	41 e0       	ldi	r20, 0x01	; 1
     cc0:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
}
     cc4:	cf 91       	pop	r28
     cc6:	df 91       	pop	r29
     cc8:	08 95       	ret

00000cca <Buzzer_off>:

void Buzzer_off(void){
     cca:	df 93       	push	r29
     ccc:	cf 93       	push	r28
     cce:	cd b7       	in	r28, 0x3d	; 61
     cd0:	de b7       	in	r29, 0x3e	; 62
	GPIO_writePin(buzzerPORT_ID,buzzerPIN_ID, LOGIC_LOW);
     cd2:	82 e0       	ldi	r24, 0x02	; 2
     cd4:	67 e0       	ldi	r22, 0x07	; 7
     cd6:	40 e0       	ldi	r20, 0x00	; 0
     cd8:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>
}
     cdc:	cf 91       	pop	r28
     cde:	df 91       	pop	r29
     ce0:	08 95       	ret

00000ce2 <EEPROM_writeByte>:
 *******************************************************************************/
#include "external_eeprom.h"
#include "twi.h"

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
     ce2:	df 93       	push	r29
     ce4:	cf 93       	push	r28
     ce6:	00 d0       	rcall	.+0      	; 0xce8 <EEPROM_writeByte+0x6>
     ce8:	00 d0       	rcall	.+0      	; 0xcea <EEPROM_writeByte+0x8>
     cea:	cd b7       	in	r28, 0x3d	; 61
     cec:	de b7       	in	r29, 0x3e	; 62
     cee:	9a 83       	std	Y+2, r25	; 0x02
     cf0:	89 83       	std	Y+1, r24	; 0x01
     cf2:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
     cf4:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <TWI_start>
    if (TWI_getStatus() != TWI_START)
     cf8:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     cfc:	88 30       	cpi	r24, 0x08	; 8
     cfe:	11 f0       	breq	.+4      	; 0xd04 <EEPROM_writeByte+0x22>
        return ERROR;
     d00:	1c 82       	std	Y+4, r1	; 0x04
     d02:	28 c0       	rjmp	.+80     	; 0xd54 <EEPROM_writeByte+0x72>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
     d04:	89 81       	ldd	r24, Y+1	; 0x01
     d06:	9a 81       	ldd	r25, Y+2	; 0x02
     d08:	80 70       	andi	r24, 0x00	; 0
     d0a:	97 70       	andi	r25, 0x07	; 7
     d0c:	88 0f       	add	r24, r24
     d0e:	89 2f       	mov	r24, r25
     d10:	88 1f       	adc	r24, r24
     d12:	99 0b       	sbc	r25, r25
     d14:	91 95       	neg	r25
     d16:	80 6a       	ori	r24, 0xA0	; 160
     d18:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
     d1c:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     d20:	88 31       	cpi	r24, 0x18	; 24
     d22:	11 f0       	breq	.+4      	; 0xd28 <EEPROM_writeByte+0x46>
        return ERROR; 
     d24:	1c 82       	std	Y+4, r1	; 0x04
     d26:	16 c0       	rjmp	.+44     	; 0xd54 <EEPROM_writeByte+0x72>
		 
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
     d28:	89 81       	ldd	r24, Y+1	; 0x01
     d2a:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     d2e:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     d32:	88 32       	cpi	r24, 0x28	; 40
     d34:	11 f0       	breq	.+4      	; 0xd3a <EEPROM_writeByte+0x58>
        return ERROR;
     d36:	1c 82       	std	Y+4, r1	; 0x04
     d38:	0d c0       	rjmp	.+26     	; 0xd54 <EEPROM_writeByte+0x72>
		
    /* write byte to eeprom */
    TWI_writeByte(u8data);
     d3a:	8b 81       	ldd	r24, Y+3	; 0x03
     d3c:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     d40:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     d44:	88 32       	cpi	r24, 0x28	; 40
     d46:	11 f0       	breq	.+4      	; 0xd4c <EEPROM_writeByte+0x6a>
        return ERROR;
     d48:	1c 82       	std	Y+4, r1	; 0x04
     d4a:	04 c0       	rjmp	.+8      	; 0xd54 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
     d4c:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <TWI_stop>
	
    return SUCCESS;
     d50:	81 e0       	ldi	r24, 0x01	; 1
     d52:	8c 83       	std	Y+4, r24	; 0x04
     d54:	8c 81       	ldd	r24, Y+4	; 0x04
}
     d56:	0f 90       	pop	r0
     d58:	0f 90       	pop	r0
     d5a:	0f 90       	pop	r0
     d5c:	0f 90       	pop	r0
     d5e:	cf 91       	pop	r28
     d60:	df 91       	pop	r29
     d62:	08 95       	ret

00000d64 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
     d64:	df 93       	push	r29
     d66:	cf 93       	push	r28
     d68:	00 d0       	rcall	.+0      	; 0xd6a <EEPROM_readByte+0x6>
     d6a:	00 d0       	rcall	.+0      	; 0xd6c <EEPROM_readByte+0x8>
     d6c:	0f 92       	push	r0
     d6e:	cd b7       	in	r28, 0x3d	; 61
     d70:	de b7       	in	r29, 0x3e	; 62
     d72:	9a 83       	std	Y+2, r25	; 0x02
     d74:	89 83       	std	Y+1, r24	; 0x01
     d76:	7c 83       	std	Y+4, r23	; 0x04
     d78:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
     d7a:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <TWI_start>
    if (TWI_getStatus() != TWI_START)
     d7e:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     d82:	88 30       	cpi	r24, 0x08	; 8
     d84:	11 f0       	breq	.+4      	; 0xd8a <EEPROM_readByte+0x26>
        return ERROR;
     d86:	1d 82       	std	Y+5, r1	; 0x05
     d88:	44 c0       	rjmp	.+136    	; 0xe12 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));
     d8a:	89 81       	ldd	r24, Y+1	; 0x01
     d8c:	9a 81       	ldd	r25, Y+2	; 0x02
     d8e:	80 70       	andi	r24, 0x00	; 0
     d90:	97 70       	andi	r25, 0x07	; 7
     d92:	88 0f       	add	r24, r24
     d94:	89 2f       	mov	r24, r25
     d96:	88 1f       	adc	r24, r24
     d98:	99 0b       	sbc	r25, r25
     d9a:	91 95       	neg	r25
     d9c:	80 6a       	ori	r24, 0xA0	; 160
     d9e:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_W_ACK)
     da2:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     da6:	88 31       	cpi	r24, 0x18	; 24
     da8:	11 f0       	breq	.+4      	; 0xdae <EEPROM_readByte+0x4a>
        return ERROR;
     daa:	1d 82       	std	Y+5, r1	; 0x05
     dac:	32 c0       	rjmp	.+100    	; 0xe12 <EEPROM_readByte+0xae>
		
    /* Send the required memory location address */
    TWI_writeByte((uint8)(u16addr));
     dae:	89 81       	ldd	r24, Y+1	; 0x01
     db0:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_DATA_ACK)
     db4:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     db8:	88 32       	cpi	r24, 0x28	; 40
     dba:	11 f0       	breq	.+4      	; 0xdc0 <EEPROM_readByte+0x5c>
        return ERROR;
     dbc:	1d 82       	std	Y+5, r1	; 0x05
     dbe:	29 c0       	rjmp	.+82     	; 0xe12 <EEPROM_readByte+0xae>
		
    /* Send the Repeated Start Bit */
    TWI_start();
     dc0:	0e 94 74 0f 	call	0x1ee8	; 0x1ee8 <TWI_start>
    if (TWI_getStatus() != TWI_REP_START)
     dc4:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     dc8:	80 31       	cpi	r24, 0x10	; 16
     dca:	11 f0       	breq	.+4      	; 0xdd0 <EEPROM_readByte+0x6c>
        return ERROR;
     dcc:	1d 82       	std	Y+5, r1	; 0x05
     dce:	21 c0       	rjmp	.+66     	; 0xe12 <EEPROM_readByte+0xae>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_writeByte((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));
     dd0:	89 81       	ldd	r24, Y+1	; 0x01
     dd2:	9a 81       	ldd	r25, Y+2	; 0x02
     dd4:	80 70       	andi	r24, 0x00	; 0
     dd6:	97 70       	andi	r25, 0x07	; 7
     dd8:	88 0f       	add	r24, r24
     dda:	89 2f       	mov	r24, r25
     ddc:	88 1f       	adc	r24, r24
     dde:	99 0b       	sbc	r25, r25
     de0:	91 95       	neg	r25
     de2:	81 6a       	ori	r24, 0xA1	; 161
     de4:	0e 94 8f 0f 	call	0x1f1e	; 0x1f1e <TWI_writeByte>
    if (TWI_getStatus() != TWI_MT_SLA_R_ACK)
     de8:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     dec:	80 34       	cpi	r24, 0x40	; 64
     dee:	11 f0       	breq	.+4      	; 0xdf4 <EEPROM_readByte+0x90>
        return ERROR;
     df0:	1d 82       	std	Y+5, r1	; 0x05
     df2:	0f c0       	rjmp	.+30     	; 0xe12 <EEPROM_readByte+0xae>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readByteWithNACK();
     df4:	0e 94 b9 0f 	call	0x1f72	; 0x1f72 <TWI_readByteWithNACK>
     df8:	eb 81       	ldd	r30, Y+3	; 0x03
     dfa:	fc 81       	ldd	r31, Y+4	; 0x04
     dfc:	80 83       	st	Z, r24
    if (TWI_getStatus() != TWI_MR_DATA_NACK)
     dfe:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <TWI_getStatus>
     e02:	88 35       	cpi	r24, 0x58	; 88
     e04:	11 f0       	breq	.+4      	; 0xe0a <EEPROM_readByte+0xa6>
        return ERROR;
     e06:	1d 82       	std	Y+5, r1	; 0x05
     e08:	04 c0       	rjmp	.+8      	; 0xe12 <EEPROM_readByte+0xae>

    /* Send the Stop Bit */
    TWI_stop();
     e0a:	0e 94 84 0f 	call	0x1f08	; 0x1f08 <TWI_stop>

    return SUCCESS;
     e0e:	81 e0       	ldi	r24, 0x01	; 1
     e10:	8d 83       	std	Y+5, r24	; 0x05
     e12:	8d 81       	ldd	r24, Y+5	; 0x05
}
     e14:	0f 90       	pop	r0
     e16:	0f 90       	pop	r0
     e18:	0f 90       	pop	r0
     e1a:	0f 90       	pop	r0
     e1c:	0f 90       	pop	r0
     e1e:	cf 91       	pop	r28
     e20:	df 91       	pop	r29
     e22:	08 95       	ret

00000e24 <GPIO_setupPinDirection>:
 * Description :
 * Setup the direction of the required pin input/output.
 * If the input port number or pin number are not correct, The function will not handle the request.
 */
void GPIO_setupPinDirection(uint8 port_num, uint8 pin_num, GPIO_PinDirectionType direction)
{
     e24:	df 93       	push	r29
     e26:	cf 93       	push	r28
     e28:	00 d0       	rcall	.+0      	; 0xe2a <GPIO_setupPinDirection+0x6>
     e2a:	00 d0       	rcall	.+0      	; 0xe2c <GPIO_setupPinDirection+0x8>
     e2c:	0f 92       	push	r0
     e2e:	cd b7       	in	r28, 0x3d	; 61
     e30:	de b7       	in	r29, 0x3e	; 62
     e32:	89 83       	std	Y+1, r24	; 0x01
     e34:	6a 83       	std	Y+2, r22	; 0x02
     e36:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
     e38:	8a 81       	ldd	r24, Y+2	; 0x02
     e3a:	88 30       	cpi	r24, 0x08	; 8
     e3c:	08 f0       	brcs	.+2      	; 0xe40 <GPIO_setupPinDirection+0x1c>
     e3e:	d5 c0       	rjmp	.+426    	; 0xfea <GPIO_setupPinDirection+0x1c6>
     e40:	89 81       	ldd	r24, Y+1	; 0x01
     e42:	84 30       	cpi	r24, 0x04	; 4
     e44:	08 f0       	brcs	.+2      	; 0xe48 <GPIO_setupPinDirection+0x24>
     e46:	d1 c0       	rjmp	.+418    	; 0xfea <GPIO_setupPinDirection+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Setup the pin direction as required */
		switch(port_num)
     e48:	89 81       	ldd	r24, Y+1	; 0x01
     e4a:	28 2f       	mov	r18, r24
     e4c:	30 e0       	ldi	r19, 0x00	; 0
     e4e:	3d 83       	std	Y+5, r19	; 0x05
     e50:	2c 83       	std	Y+4, r18	; 0x04
     e52:	8c 81       	ldd	r24, Y+4	; 0x04
     e54:	9d 81       	ldd	r25, Y+5	; 0x05
     e56:	81 30       	cpi	r24, 0x01	; 1
     e58:	91 05       	cpc	r25, r1
     e5a:	09 f4       	brne	.+2      	; 0xe5e <GPIO_setupPinDirection+0x3a>
     e5c:	43 c0       	rjmp	.+134    	; 0xee4 <GPIO_setupPinDirection+0xc0>
     e5e:	2c 81       	ldd	r18, Y+4	; 0x04
     e60:	3d 81       	ldd	r19, Y+5	; 0x05
     e62:	22 30       	cpi	r18, 0x02	; 2
     e64:	31 05       	cpc	r19, r1
     e66:	2c f4       	brge	.+10     	; 0xe72 <GPIO_setupPinDirection+0x4e>
     e68:	8c 81       	ldd	r24, Y+4	; 0x04
     e6a:	9d 81       	ldd	r25, Y+5	; 0x05
     e6c:	00 97       	sbiw	r24, 0x00	; 0
     e6e:	71 f0       	breq	.+28     	; 0xe8c <GPIO_setupPinDirection+0x68>
     e70:	bc c0       	rjmp	.+376    	; 0xfea <GPIO_setupPinDirection+0x1c6>
     e72:	2c 81       	ldd	r18, Y+4	; 0x04
     e74:	3d 81       	ldd	r19, Y+5	; 0x05
     e76:	22 30       	cpi	r18, 0x02	; 2
     e78:	31 05       	cpc	r19, r1
     e7a:	09 f4       	brne	.+2      	; 0xe7e <GPIO_setupPinDirection+0x5a>
     e7c:	5f c0       	rjmp	.+190    	; 0xf3c <GPIO_setupPinDirection+0x118>
     e7e:	8c 81       	ldd	r24, Y+4	; 0x04
     e80:	9d 81       	ldd	r25, Y+5	; 0x05
     e82:	83 30       	cpi	r24, 0x03	; 3
     e84:	91 05       	cpc	r25, r1
     e86:	09 f4       	brne	.+2      	; 0xe8a <GPIO_setupPinDirection+0x66>
     e88:	85 c0       	rjmp	.+266    	; 0xf94 <GPIO_setupPinDirection+0x170>
     e8a:	af c0       	rjmp	.+350    	; 0xfea <GPIO_setupPinDirection+0x1c6>
		{
		case PORTA_ID:
			if(direction == PIN_OUTPUT)
     e8c:	8b 81       	ldd	r24, Y+3	; 0x03
     e8e:	81 30       	cpi	r24, 0x01	; 1
     e90:	a1 f4       	brne	.+40     	; 0xeba <GPIO_setupPinDirection+0x96>
			{
				SET_BIT(DDRA,pin_num);
     e92:	aa e3       	ldi	r26, 0x3A	; 58
     e94:	b0 e0       	ldi	r27, 0x00	; 0
     e96:	ea e3       	ldi	r30, 0x3A	; 58
     e98:	f0 e0       	ldi	r31, 0x00	; 0
     e9a:	80 81       	ld	r24, Z
     e9c:	48 2f       	mov	r20, r24
     e9e:	8a 81       	ldd	r24, Y+2	; 0x02
     ea0:	28 2f       	mov	r18, r24
     ea2:	30 e0       	ldi	r19, 0x00	; 0
     ea4:	81 e0       	ldi	r24, 0x01	; 1
     ea6:	90 e0       	ldi	r25, 0x00	; 0
     ea8:	02 2e       	mov	r0, r18
     eaa:	02 c0       	rjmp	.+4      	; 0xeb0 <GPIO_setupPinDirection+0x8c>
     eac:	88 0f       	add	r24, r24
     eae:	99 1f       	adc	r25, r25
     eb0:	0a 94       	dec	r0
     eb2:	e2 f7       	brpl	.-8      	; 0xeac <GPIO_setupPinDirection+0x88>
     eb4:	84 2b       	or	r24, r20
     eb6:	8c 93       	st	X, r24
     eb8:	98 c0       	rjmp	.+304    	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRA,pin_num);
     eba:	aa e3       	ldi	r26, 0x3A	; 58
     ebc:	b0 e0       	ldi	r27, 0x00	; 0
     ebe:	ea e3       	ldi	r30, 0x3A	; 58
     ec0:	f0 e0       	ldi	r31, 0x00	; 0
     ec2:	80 81       	ld	r24, Z
     ec4:	48 2f       	mov	r20, r24
     ec6:	8a 81       	ldd	r24, Y+2	; 0x02
     ec8:	28 2f       	mov	r18, r24
     eca:	30 e0       	ldi	r19, 0x00	; 0
     ecc:	81 e0       	ldi	r24, 0x01	; 1
     ece:	90 e0       	ldi	r25, 0x00	; 0
     ed0:	02 2e       	mov	r0, r18
     ed2:	02 c0       	rjmp	.+4      	; 0xed8 <GPIO_setupPinDirection+0xb4>
     ed4:	88 0f       	add	r24, r24
     ed6:	99 1f       	adc	r25, r25
     ed8:	0a 94       	dec	r0
     eda:	e2 f7       	brpl	.-8      	; 0xed4 <GPIO_setupPinDirection+0xb0>
     edc:	80 95       	com	r24
     ede:	84 23       	and	r24, r20
     ee0:	8c 93       	st	X, r24
     ee2:	83 c0       	rjmp	.+262    	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTB_ID:
			if(direction == PIN_OUTPUT)
     ee4:	8b 81       	ldd	r24, Y+3	; 0x03
     ee6:	81 30       	cpi	r24, 0x01	; 1
     ee8:	a1 f4       	brne	.+40     	; 0xf12 <GPIO_setupPinDirection+0xee>
			{
				SET_BIT(DDRB,pin_num);
     eea:	a7 e3       	ldi	r26, 0x37	; 55
     eec:	b0 e0       	ldi	r27, 0x00	; 0
     eee:	e7 e3       	ldi	r30, 0x37	; 55
     ef0:	f0 e0       	ldi	r31, 0x00	; 0
     ef2:	80 81       	ld	r24, Z
     ef4:	48 2f       	mov	r20, r24
     ef6:	8a 81       	ldd	r24, Y+2	; 0x02
     ef8:	28 2f       	mov	r18, r24
     efa:	30 e0       	ldi	r19, 0x00	; 0
     efc:	81 e0       	ldi	r24, 0x01	; 1
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	02 2e       	mov	r0, r18
     f02:	02 c0       	rjmp	.+4      	; 0xf08 <GPIO_setupPinDirection+0xe4>
     f04:	88 0f       	add	r24, r24
     f06:	99 1f       	adc	r25, r25
     f08:	0a 94       	dec	r0
     f0a:	e2 f7       	brpl	.-8      	; 0xf04 <GPIO_setupPinDirection+0xe0>
     f0c:	84 2b       	or	r24, r20
     f0e:	8c 93       	st	X, r24
     f10:	6c c0       	rjmp	.+216    	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRB,pin_num);
     f12:	a7 e3       	ldi	r26, 0x37	; 55
     f14:	b0 e0       	ldi	r27, 0x00	; 0
     f16:	e7 e3       	ldi	r30, 0x37	; 55
     f18:	f0 e0       	ldi	r31, 0x00	; 0
     f1a:	80 81       	ld	r24, Z
     f1c:	48 2f       	mov	r20, r24
     f1e:	8a 81       	ldd	r24, Y+2	; 0x02
     f20:	28 2f       	mov	r18, r24
     f22:	30 e0       	ldi	r19, 0x00	; 0
     f24:	81 e0       	ldi	r24, 0x01	; 1
     f26:	90 e0       	ldi	r25, 0x00	; 0
     f28:	02 2e       	mov	r0, r18
     f2a:	02 c0       	rjmp	.+4      	; 0xf30 <GPIO_setupPinDirection+0x10c>
     f2c:	88 0f       	add	r24, r24
     f2e:	99 1f       	adc	r25, r25
     f30:	0a 94       	dec	r0
     f32:	e2 f7       	brpl	.-8      	; 0xf2c <GPIO_setupPinDirection+0x108>
     f34:	80 95       	com	r24
     f36:	84 23       	and	r24, r20
     f38:	8c 93       	st	X, r24
     f3a:	57 c0       	rjmp	.+174    	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTC_ID:
			if(direction == PIN_OUTPUT)
     f3c:	8b 81       	ldd	r24, Y+3	; 0x03
     f3e:	81 30       	cpi	r24, 0x01	; 1
     f40:	a1 f4       	brne	.+40     	; 0xf6a <GPIO_setupPinDirection+0x146>
			{
				SET_BIT(DDRC,pin_num);
     f42:	a4 e3       	ldi	r26, 0x34	; 52
     f44:	b0 e0       	ldi	r27, 0x00	; 0
     f46:	e4 e3       	ldi	r30, 0x34	; 52
     f48:	f0 e0       	ldi	r31, 0x00	; 0
     f4a:	80 81       	ld	r24, Z
     f4c:	48 2f       	mov	r20, r24
     f4e:	8a 81       	ldd	r24, Y+2	; 0x02
     f50:	28 2f       	mov	r18, r24
     f52:	30 e0       	ldi	r19, 0x00	; 0
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	02 2e       	mov	r0, r18
     f5a:	02 c0       	rjmp	.+4      	; 0xf60 <GPIO_setupPinDirection+0x13c>
     f5c:	88 0f       	add	r24, r24
     f5e:	99 1f       	adc	r25, r25
     f60:	0a 94       	dec	r0
     f62:	e2 f7       	brpl	.-8      	; 0xf5c <GPIO_setupPinDirection+0x138>
     f64:	84 2b       	or	r24, r20
     f66:	8c 93       	st	X, r24
     f68:	40 c0       	rjmp	.+128    	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRC,pin_num);
     f6a:	a4 e3       	ldi	r26, 0x34	; 52
     f6c:	b0 e0       	ldi	r27, 0x00	; 0
     f6e:	e4 e3       	ldi	r30, 0x34	; 52
     f70:	f0 e0       	ldi	r31, 0x00	; 0
     f72:	80 81       	ld	r24, Z
     f74:	48 2f       	mov	r20, r24
     f76:	8a 81       	ldd	r24, Y+2	; 0x02
     f78:	28 2f       	mov	r18, r24
     f7a:	30 e0       	ldi	r19, 0x00	; 0
     f7c:	81 e0       	ldi	r24, 0x01	; 1
     f7e:	90 e0       	ldi	r25, 0x00	; 0
     f80:	02 2e       	mov	r0, r18
     f82:	02 c0       	rjmp	.+4      	; 0xf88 <GPIO_setupPinDirection+0x164>
     f84:	88 0f       	add	r24, r24
     f86:	99 1f       	adc	r25, r25
     f88:	0a 94       	dec	r0
     f8a:	e2 f7       	brpl	.-8      	; 0xf84 <GPIO_setupPinDirection+0x160>
     f8c:	80 95       	com	r24
     f8e:	84 23       	and	r24, r20
     f90:	8c 93       	st	X, r24
     f92:	2b c0       	rjmp	.+86     	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			break;
		case PORTD_ID:
			if(direction == PIN_OUTPUT)
     f94:	8b 81       	ldd	r24, Y+3	; 0x03
     f96:	81 30       	cpi	r24, 0x01	; 1
     f98:	a1 f4       	brne	.+40     	; 0xfc2 <GPIO_setupPinDirection+0x19e>
			{
				SET_BIT(DDRD,pin_num);
     f9a:	a1 e3       	ldi	r26, 0x31	; 49
     f9c:	b0 e0       	ldi	r27, 0x00	; 0
     f9e:	e1 e3       	ldi	r30, 0x31	; 49
     fa0:	f0 e0       	ldi	r31, 0x00	; 0
     fa2:	80 81       	ld	r24, Z
     fa4:	48 2f       	mov	r20, r24
     fa6:	8a 81       	ldd	r24, Y+2	; 0x02
     fa8:	28 2f       	mov	r18, r24
     faa:	30 e0       	ldi	r19, 0x00	; 0
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	02 2e       	mov	r0, r18
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <GPIO_setupPinDirection+0x194>
     fb4:	88 0f       	add	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	0a 94       	dec	r0
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <GPIO_setupPinDirection+0x190>
     fbc:	84 2b       	or	r24, r20
     fbe:	8c 93       	st	X, r24
     fc0:	14 c0       	rjmp	.+40     	; 0xfea <GPIO_setupPinDirection+0x1c6>
			}
			else
			{
				CLEAR_BIT(DDRD,pin_num);
     fc2:	a1 e3       	ldi	r26, 0x31	; 49
     fc4:	b0 e0       	ldi	r27, 0x00	; 0
     fc6:	e1 e3       	ldi	r30, 0x31	; 49
     fc8:	f0 e0       	ldi	r31, 0x00	; 0
     fca:	80 81       	ld	r24, Z
     fcc:	48 2f       	mov	r20, r24
     fce:	8a 81       	ldd	r24, Y+2	; 0x02
     fd0:	28 2f       	mov	r18, r24
     fd2:	30 e0       	ldi	r19, 0x00	; 0
     fd4:	81 e0       	ldi	r24, 0x01	; 1
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	02 2e       	mov	r0, r18
     fda:	02 c0       	rjmp	.+4      	; 0xfe0 <GPIO_setupPinDirection+0x1bc>
     fdc:	88 0f       	add	r24, r24
     fde:	99 1f       	adc	r25, r25
     fe0:	0a 94       	dec	r0
     fe2:	e2 f7       	brpl	.-8      	; 0xfdc <GPIO_setupPinDirection+0x1b8>
     fe4:	80 95       	com	r24
     fe6:	84 23       	and	r24, r20
     fe8:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
     fea:	0f 90       	pop	r0
     fec:	0f 90       	pop	r0
     fee:	0f 90       	pop	r0
     ff0:	0f 90       	pop	r0
     ff2:	0f 90       	pop	r0
     ff4:	cf 91       	pop	r28
     ff6:	df 91       	pop	r29
     ff8:	08 95       	ret

00000ffa <GPIO_writePin>:
 * Write the value Logic High or Logic Low on the required pin.
 * If the input port number or pin number are not correct, The function will not handle the request.
 * If the pin is input, this function will enable/disable the internal pull-up resistor.
 */
void GPIO_writePin(uint8 port_num, uint8 pin_num, uint8 value)
{
     ffa:	df 93       	push	r29
     ffc:	cf 93       	push	r28
     ffe:	00 d0       	rcall	.+0      	; 0x1000 <GPIO_writePin+0x6>
    1000:	00 d0       	rcall	.+0      	; 0x1002 <GPIO_writePin+0x8>
    1002:	0f 92       	push	r0
    1004:	cd b7       	in	r28, 0x3d	; 61
    1006:	de b7       	in	r29, 0x3e	; 62
    1008:	89 83       	std	Y+1, r24	; 0x01
    100a:	6a 83       	std	Y+2, r22	; 0x02
    100c:	4b 83       	std	Y+3, r20	; 0x03
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    100e:	8a 81       	ldd	r24, Y+2	; 0x02
    1010:	88 30       	cpi	r24, 0x08	; 8
    1012:	08 f0       	brcs	.+2      	; 0x1016 <GPIO_writePin+0x1c>
    1014:	d5 c0       	rjmp	.+426    	; 0x11c0 <GPIO_writePin+0x1c6>
    1016:	89 81       	ldd	r24, Y+1	; 0x01
    1018:	84 30       	cpi	r24, 0x04	; 4
    101a:	08 f0       	brcs	.+2      	; 0x101e <GPIO_writePin+0x24>
    101c:	d1 c0       	rjmp	.+418    	; 0x11c0 <GPIO_writePin+0x1c6>
		/* Do Nothing */
	}
	else
	{
		/* Write the pin value as required */
		switch(port_num)
    101e:	89 81       	ldd	r24, Y+1	; 0x01
    1020:	28 2f       	mov	r18, r24
    1022:	30 e0       	ldi	r19, 0x00	; 0
    1024:	3d 83       	std	Y+5, r19	; 0x05
    1026:	2c 83       	std	Y+4, r18	; 0x04
    1028:	8c 81       	ldd	r24, Y+4	; 0x04
    102a:	9d 81       	ldd	r25, Y+5	; 0x05
    102c:	81 30       	cpi	r24, 0x01	; 1
    102e:	91 05       	cpc	r25, r1
    1030:	09 f4       	brne	.+2      	; 0x1034 <GPIO_writePin+0x3a>
    1032:	43 c0       	rjmp	.+134    	; 0x10ba <GPIO_writePin+0xc0>
    1034:	2c 81       	ldd	r18, Y+4	; 0x04
    1036:	3d 81       	ldd	r19, Y+5	; 0x05
    1038:	22 30       	cpi	r18, 0x02	; 2
    103a:	31 05       	cpc	r19, r1
    103c:	2c f4       	brge	.+10     	; 0x1048 <GPIO_writePin+0x4e>
    103e:	8c 81       	ldd	r24, Y+4	; 0x04
    1040:	9d 81       	ldd	r25, Y+5	; 0x05
    1042:	00 97       	sbiw	r24, 0x00	; 0
    1044:	71 f0       	breq	.+28     	; 0x1062 <GPIO_writePin+0x68>
    1046:	bc c0       	rjmp	.+376    	; 0x11c0 <GPIO_writePin+0x1c6>
    1048:	2c 81       	ldd	r18, Y+4	; 0x04
    104a:	3d 81       	ldd	r19, Y+5	; 0x05
    104c:	22 30       	cpi	r18, 0x02	; 2
    104e:	31 05       	cpc	r19, r1
    1050:	09 f4       	brne	.+2      	; 0x1054 <GPIO_writePin+0x5a>
    1052:	5f c0       	rjmp	.+190    	; 0x1112 <GPIO_writePin+0x118>
    1054:	8c 81       	ldd	r24, Y+4	; 0x04
    1056:	9d 81       	ldd	r25, Y+5	; 0x05
    1058:	83 30       	cpi	r24, 0x03	; 3
    105a:	91 05       	cpc	r25, r1
    105c:	09 f4       	brne	.+2      	; 0x1060 <GPIO_writePin+0x66>
    105e:	85 c0       	rjmp	.+266    	; 0x116a <GPIO_writePin+0x170>
    1060:	af c0       	rjmp	.+350    	; 0x11c0 <GPIO_writePin+0x1c6>
		{
		case PORTA_ID:
			if(value == LOGIC_HIGH)
    1062:	8b 81       	ldd	r24, Y+3	; 0x03
    1064:	81 30       	cpi	r24, 0x01	; 1
    1066:	a1 f4       	brne	.+40     	; 0x1090 <GPIO_writePin+0x96>
			{
				SET_BIT(PORTA,pin_num);
    1068:	ab e3       	ldi	r26, 0x3B	; 59
    106a:	b0 e0       	ldi	r27, 0x00	; 0
    106c:	eb e3       	ldi	r30, 0x3B	; 59
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	80 81       	ld	r24, Z
    1072:	48 2f       	mov	r20, r24
    1074:	8a 81       	ldd	r24, Y+2	; 0x02
    1076:	28 2f       	mov	r18, r24
    1078:	30 e0       	ldi	r19, 0x00	; 0
    107a:	81 e0       	ldi	r24, 0x01	; 1
    107c:	90 e0       	ldi	r25, 0x00	; 0
    107e:	02 2e       	mov	r0, r18
    1080:	02 c0       	rjmp	.+4      	; 0x1086 <GPIO_writePin+0x8c>
    1082:	88 0f       	add	r24, r24
    1084:	99 1f       	adc	r25, r25
    1086:	0a 94       	dec	r0
    1088:	e2 f7       	brpl	.-8      	; 0x1082 <GPIO_writePin+0x88>
    108a:	84 2b       	or	r24, r20
    108c:	8c 93       	st	X, r24
    108e:	98 c0       	rjmp	.+304    	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTA,pin_num);
    1090:	ab e3       	ldi	r26, 0x3B	; 59
    1092:	b0 e0       	ldi	r27, 0x00	; 0
    1094:	eb e3       	ldi	r30, 0x3B	; 59
    1096:	f0 e0       	ldi	r31, 0x00	; 0
    1098:	80 81       	ld	r24, Z
    109a:	48 2f       	mov	r20, r24
    109c:	8a 81       	ldd	r24, Y+2	; 0x02
    109e:	28 2f       	mov	r18, r24
    10a0:	30 e0       	ldi	r19, 0x00	; 0
    10a2:	81 e0       	ldi	r24, 0x01	; 1
    10a4:	90 e0       	ldi	r25, 0x00	; 0
    10a6:	02 2e       	mov	r0, r18
    10a8:	02 c0       	rjmp	.+4      	; 0x10ae <GPIO_writePin+0xb4>
    10aa:	88 0f       	add	r24, r24
    10ac:	99 1f       	adc	r25, r25
    10ae:	0a 94       	dec	r0
    10b0:	e2 f7       	brpl	.-8      	; 0x10aa <GPIO_writePin+0xb0>
    10b2:	80 95       	com	r24
    10b4:	84 23       	and	r24, r20
    10b6:	8c 93       	st	X, r24
    10b8:	83 c0       	rjmp	.+262    	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTB_ID:
			if(value == LOGIC_HIGH)
    10ba:	8b 81       	ldd	r24, Y+3	; 0x03
    10bc:	81 30       	cpi	r24, 0x01	; 1
    10be:	a1 f4       	brne	.+40     	; 0x10e8 <GPIO_writePin+0xee>
			{
				SET_BIT(PORTB,pin_num);
    10c0:	a8 e3       	ldi	r26, 0x38	; 56
    10c2:	b0 e0       	ldi	r27, 0x00	; 0
    10c4:	e8 e3       	ldi	r30, 0x38	; 56
    10c6:	f0 e0       	ldi	r31, 0x00	; 0
    10c8:	80 81       	ld	r24, Z
    10ca:	48 2f       	mov	r20, r24
    10cc:	8a 81       	ldd	r24, Y+2	; 0x02
    10ce:	28 2f       	mov	r18, r24
    10d0:	30 e0       	ldi	r19, 0x00	; 0
    10d2:	81 e0       	ldi	r24, 0x01	; 1
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	02 2e       	mov	r0, r18
    10d8:	02 c0       	rjmp	.+4      	; 0x10de <GPIO_writePin+0xe4>
    10da:	88 0f       	add	r24, r24
    10dc:	99 1f       	adc	r25, r25
    10de:	0a 94       	dec	r0
    10e0:	e2 f7       	brpl	.-8      	; 0x10da <GPIO_writePin+0xe0>
    10e2:	84 2b       	or	r24, r20
    10e4:	8c 93       	st	X, r24
    10e6:	6c c0       	rjmp	.+216    	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTB,pin_num);
    10e8:	a8 e3       	ldi	r26, 0x38	; 56
    10ea:	b0 e0       	ldi	r27, 0x00	; 0
    10ec:	e8 e3       	ldi	r30, 0x38	; 56
    10ee:	f0 e0       	ldi	r31, 0x00	; 0
    10f0:	80 81       	ld	r24, Z
    10f2:	48 2f       	mov	r20, r24
    10f4:	8a 81       	ldd	r24, Y+2	; 0x02
    10f6:	28 2f       	mov	r18, r24
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	81 e0       	ldi	r24, 0x01	; 1
    10fc:	90 e0       	ldi	r25, 0x00	; 0
    10fe:	02 2e       	mov	r0, r18
    1100:	02 c0       	rjmp	.+4      	; 0x1106 <GPIO_writePin+0x10c>
    1102:	88 0f       	add	r24, r24
    1104:	99 1f       	adc	r25, r25
    1106:	0a 94       	dec	r0
    1108:	e2 f7       	brpl	.-8      	; 0x1102 <GPIO_writePin+0x108>
    110a:	80 95       	com	r24
    110c:	84 23       	and	r24, r20
    110e:	8c 93       	st	X, r24
    1110:	57 c0       	rjmp	.+174    	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTC_ID:
			if(value == LOGIC_HIGH)
    1112:	8b 81       	ldd	r24, Y+3	; 0x03
    1114:	81 30       	cpi	r24, 0x01	; 1
    1116:	a1 f4       	brne	.+40     	; 0x1140 <GPIO_writePin+0x146>
			{
				SET_BIT(PORTC,pin_num);
    1118:	a5 e3       	ldi	r26, 0x35	; 53
    111a:	b0 e0       	ldi	r27, 0x00	; 0
    111c:	e5 e3       	ldi	r30, 0x35	; 53
    111e:	f0 e0       	ldi	r31, 0x00	; 0
    1120:	80 81       	ld	r24, Z
    1122:	48 2f       	mov	r20, r24
    1124:	8a 81       	ldd	r24, Y+2	; 0x02
    1126:	28 2f       	mov	r18, r24
    1128:	30 e0       	ldi	r19, 0x00	; 0
    112a:	81 e0       	ldi	r24, 0x01	; 1
    112c:	90 e0       	ldi	r25, 0x00	; 0
    112e:	02 2e       	mov	r0, r18
    1130:	02 c0       	rjmp	.+4      	; 0x1136 <GPIO_writePin+0x13c>
    1132:	88 0f       	add	r24, r24
    1134:	99 1f       	adc	r25, r25
    1136:	0a 94       	dec	r0
    1138:	e2 f7       	brpl	.-8      	; 0x1132 <GPIO_writePin+0x138>
    113a:	84 2b       	or	r24, r20
    113c:	8c 93       	st	X, r24
    113e:	40 c0       	rjmp	.+128    	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTC,pin_num);
    1140:	a5 e3       	ldi	r26, 0x35	; 53
    1142:	b0 e0       	ldi	r27, 0x00	; 0
    1144:	e5 e3       	ldi	r30, 0x35	; 53
    1146:	f0 e0       	ldi	r31, 0x00	; 0
    1148:	80 81       	ld	r24, Z
    114a:	48 2f       	mov	r20, r24
    114c:	8a 81       	ldd	r24, Y+2	; 0x02
    114e:	28 2f       	mov	r18, r24
    1150:	30 e0       	ldi	r19, 0x00	; 0
    1152:	81 e0       	ldi	r24, 0x01	; 1
    1154:	90 e0       	ldi	r25, 0x00	; 0
    1156:	02 2e       	mov	r0, r18
    1158:	02 c0       	rjmp	.+4      	; 0x115e <GPIO_writePin+0x164>
    115a:	88 0f       	add	r24, r24
    115c:	99 1f       	adc	r25, r25
    115e:	0a 94       	dec	r0
    1160:	e2 f7       	brpl	.-8      	; 0x115a <GPIO_writePin+0x160>
    1162:	80 95       	com	r24
    1164:	84 23       	and	r24, r20
    1166:	8c 93       	st	X, r24
    1168:	2b c0       	rjmp	.+86     	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			break;
		case PORTD_ID:
			if(value == LOGIC_HIGH)
    116a:	8b 81       	ldd	r24, Y+3	; 0x03
    116c:	81 30       	cpi	r24, 0x01	; 1
    116e:	a1 f4       	brne	.+40     	; 0x1198 <GPIO_writePin+0x19e>
			{
				SET_BIT(PORTD,pin_num);
    1170:	a2 e3       	ldi	r26, 0x32	; 50
    1172:	b0 e0       	ldi	r27, 0x00	; 0
    1174:	e2 e3       	ldi	r30, 0x32	; 50
    1176:	f0 e0       	ldi	r31, 0x00	; 0
    1178:	80 81       	ld	r24, Z
    117a:	48 2f       	mov	r20, r24
    117c:	8a 81       	ldd	r24, Y+2	; 0x02
    117e:	28 2f       	mov	r18, r24
    1180:	30 e0       	ldi	r19, 0x00	; 0
    1182:	81 e0       	ldi	r24, 0x01	; 1
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	02 2e       	mov	r0, r18
    1188:	02 c0       	rjmp	.+4      	; 0x118e <GPIO_writePin+0x194>
    118a:	88 0f       	add	r24, r24
    118c:	99 1f       	adc	r25, r25
    118e:	0a 94       	dec	r0
    1190:	e2 f7       	brpl	.-8      	; 0x118a <GPIO_writePin+0x190>
    1192:	84 2b       	or	r24, r20
    1194:	8c 93       	st	X, r24
    1196:	14 c0       	rjmp	.+40     	; 0x11c0 <GPIO_writePin+0x1c6>
			}
			else
			{
				CLEAR_BIT(PORTD,pin_num);
    1198:	a2 e3       	ldi	r26, 0x32	; 50
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	e2 e3       	ldi	r30, 0x32	; 50
    119e:	f0 e0       	ldi	r31, 0x00	; 0
    11a0:	80 81       	ld	r24, Z
    11a2:	48 2f       	mov	r20, r24
    11a4:	8a 81       	ldd	r24, Y+2	; 0x02
    11a6:	28 2f       	mov	r18, r24
    11a8:	30 e0       	ldi	r19, 0x00	; 0
    11aa:	81 e0       	ldi	r24, 0x01	; 1
    11ac:	90 e0       	ldi	r25, 0x00	; 0
    11ae:	02 2e       	mov	r0, r18
    11b0:	02 c0       	rjmp	.+4      	; 0x11b6 <GPIO_writePin+0x1bc>
    11b2:	88 0f       	add	r24, r24
    11b4:	99 1f       	adc	r25, r25
    11b6:	0a 94       	dec	r0
    11b8:	e2 f7       	brpl	.-8      	; 0x11b2 <GPIO_writePin+0x1b8>
    11ba:	80 95       	com	r24
    11bc:	84 23       	and	r24, r20
    11be:	8c 93       	st	X, r24
			}
			break;
		}
	}
}
    11c0:	0f 90       	pop	r0
    11c2:	0f 90       	pop	r0
    11c4:	0f 90       	pop	r0
    11c6:	0f 90       	pop	r0
    11c8:	0f 90       	pop	r0
    11ca:	cf 91       	pop	r28
    11cc:	df 91       	pop	r29
    11ce:	08 95       	ret

000011d0 <GPIO_readPin>:
 * Description :
 * Read and return the value for the required pin, it should be Logic High or Logic Low.
 * If the input port number or pin number are not correct, The function will return Logic Low.
 */
uint8 GPIO_readPin(uint8 port_num, uint8 pin_num)
{
    11d0:	df 93       	push	r29
    11d2:	cf 93       	push	r28
    11d4:	00 d0       	rcall	.+0      	; 0x11d6 <GPIO_readPin+0x6>
    11d6:	00 d0       	rcall	.+0      	; 0x11d8 <GPIO_readPin+0x8>
    11d8:	0f 92       	push	r0
    11da:	cd b7       	in	r28, 0x3d	; 61
    11dc:	de b7       	in	r29, 0x3e	; 62
    11de:	8a 83       	std	Y+2, r24	; 0x02
    11e0:	6b 83       	std	Y+3, r22	; 0x03
	uint8 pin_value = LOGIC_LOW;
    11e2:	19 82       	std	Y+1, r1	; 0x01
	/*
	 * Check if the input port number is greater than NUM_OF_PINS_PER_PORT value.
	 * Or if the input pin number is greater than NUM_OF_PINS_PER_PORT value.
	 * In this case the input is not valid port/pin number
	 */
	if((pin_num >= NUM_OF_PINS_PER_PORT) || (port_num >= NUM_OF_PORTS))
    11e4:	8b 81       	ldd	r24, Y+3	; 0x03
    11e6:	88 30       	cpi	r24, 0x08	; 8
    11e8:	08 f0       	brcs	.+2      	; 0x11ec <GPIO_readPin+0x1c>
    11ea:	84 c0       	rjmp	.+264    	; 0x12f4 <GPIO_readPin+0x124>
    11ec:	8a 81       	ldd	r24, Y+2	; 0x02
    11ee:	84 30       	cpi	r24, 0x04	; 4
    11f0:	08 f0       	brcs	.+2      	; 0x11f4 <GPIO_readPin+0x24>
    11f2:	80 c0       	rjmp	.+256    	; 0x12f4 <GPIO_readPin+0x124>
		/* Do Nothing */
	}
	else
	{
		/* Read the pin value as required */
		switch(port_num)
    11f4:	8a 81       	ldd	r24, Y+2	; 0x02
    11f6:	28 2f       	mov	r18, r24
    11f8:	30 e0       	ldi	r19, 0x00	; 0
    11fa:	3d 83       	std	Y+5, r19	; 0x05
    11fc:	2c 83       	std	Y+4, r18	; 0x04
    11fe:	4c 81       	ldd	r20, Y+4	; 0x04
    1200:	5d 81       	ldd	r21, Y+5	; 0x05
    1202:	41 30       	cpi	r20, 0x01	; 1
    1204:	51 05       	cpc	r21, r1
    1206:	79 f1       	breq	.+94     	; 0x1266 <GPIO_readPin+0x96>
    1208:	8c 81       	ldd	r24, Y+4	; 0x04
    120a:	9d 81       	ldd	r25, Y+5	; 0x05
    120c:	82 30       	cpi	r24, 0x02	; 2
    120e:	91 05       	cpc	r25, r1
    1210:	34 f4       	brge	.+12     	; 0x121e <GPIO_readPin+0x4e>
    1212:	2c 81       	ldd	r18, Y+4	; 0x04
    1214:	3d 81       	ldd	r19, Y+5	; 0x05
    1216:	21 15       	cp	r18, r1
    1218:	31 05       	cpc	r19, r1
    121a:	69 f0       	breq	.+26     	; 0x1236 <GPIO_readPin+0x66>
    121c:	6b c0       	rjmp	.+214    	; 0x12f4 <GPIO_readPin+0x124>
    121e:	4c 81       	ldd	r20, Y+4	; 0x04
    1220:	5d 81       	ldd	r21, Y+5	; 0x05
    1222:	42 30       	cpi	r20, 0x02	; 2
    1224:	51 05       	cpc	r21, r1
    1226:	b9 f1       	breq	.+110    	; 0x1296 <GPIO_readPin+0xc6>
    1228:	8c 81       	ldd	r24, Y+4	; 0x04
    122a:	9d 81       	ldd	r25, Y+5	; 0x05
    122c:	83 30       	cpi	r24, 0x03	; 3
    122e:	91 05       	cpc	r25, r1
    1230:	09 f4       	brne	.+2      	; 0x1234 <GPIO_readPin+0x64>
    1232:	49 c0       	rjmp	.+146    	; 0x12c6 <GPIO_readPin+0xf6>
    1234:	5f c0       	rjmp	.+190    	; 0x12f4 <GPIO_readPin+0x124>
		{
		case PORTA_ID:
			if(BIT_IS_SET(PINA,pin_num))
    1236:	e9 e3       	ldi	r30, 0x39	; 57
    1238:	f0 e0       	ldi	r31, 0x00	; 0
    123a:	80 81       	ld	r24, Z
    123c:	28 2f       	mov	r18, r24
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	8b 81       	ldd	r24, Y+3	; 0x03
    1242:	88 2f       	mov	r24, r24
    1244:	90 e0       	ldi	r25, 0x00	; 0
    1246:	a9 01       	movw	r20, r18
    1248:	02 c0       	rjmp	.+4      	; 0x124e <GPIO_readPin+0x7e>
    124a:	55 95       	asr	r21
    124c:	47 95       	ror	r20
    124e:	8a 95       	dec	r24
    1250:	e2 f7       	brpl	.-8      	; 0x124a <GPIO_readPin+0x7a>
    1252:	ca 01       	movw	r24, r20
    1254:	81 70       	andi	r24, 0x01	; 1
    1256:	90 70       	andi	r25, 0x00	; 0
    1258:	88 23       	and	r24, r24
    125a:	19 f0       	breq	.+6      	; 0x1262 <GPIO_readPin+0x92>
			{
				pin_value = LOGIC_HIGH;
    125c:	81 e0       	ldi	r24, 0x01	; 1
    125e:	89 83       	std	Y+1, r24	; 0x01
    1260:	49 c0       	rjmp	.+146    	; 0x12f4 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1262:	19 82       	std	Y+1, r1	; 0x01
    1264:	47 c0       	rjmp	.+142    	; 0x12f4 <GPIO_readPin+0x124>
			}
			break;
		case PORTB_ID:
			if(BIT_IS_SET(PINB,pin_num))
    1266:	e6 e3       	ldi	r30, 0x36	; 54
    1268:	f0 e0       	ldi	r31, 0x00	; 0
    126a:	80 81       	ld	r24, Z
    126c:	28 2f       	mov	r18, r24
    126e:	30 e0       	ldi	r19, 0x00	; 0
    1270:	8b 81       	ldd	r24, Y+3	; 0x03
    1272:	88 2f       	mov	r24, r24
    1274:	90 e0       	ldi	r25, 0x00	; 0
    1276:	a9 01       	movw	r20, r18
    1278:	02 c0       	rjmp	.+4      	; 0x127e <GPIO_readPin+0xae>
    127a:	55 95       	asr	r21
    127c:	47 95       	ror	r20
    127e:	8a 95       	dec	r24
    1280:	e2 f7       	brpl	.-8      	; 0x127a <GPIO_readPin+0xaa>
    1282:	ca 01       	movw	r24, r20
    1284:	81 70       	andi	r24, 0x01	; 1
    1286:	90 70       	andi	r25, 0x00	; 0
    1288:	88 23       	and	r24, r24
    128a:	19 f0       	breq	.+6      	; 0x1292 <GPIO_readPin+0xc2>
			{
				pin_value = LOGIC_HIGH;
    128c:	81 e0       	ldi	r24, 0x01	; 1
    128e:	89 83       	std	Y+1, r24	; 0x01
    1290:	31 c0       	rjmp	.+98     	; 0x12f4 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    1292:	19 82       	std	Y+1, r1	; 0x01
    1294:	2f c0       	rjmp	.+94     	; 0x12f4 <GPIO_readPin+0x124>
			}
			break;
		case PORTC_ID:
			if(BIT_IS_SET(PINC,pin_num))
    1296:	e3 e3       	ldi	r30, 0x33	; 51
    1298:	f0 e0       	ldi	r31, 0x00	; 0
    129a:	80 81       	ld	r24, Z
    129c:	28 2f       	mov	r18, r24
    129e:	30 e0       	ldi	r19, 0x00	; 0
    12a0:	8b 81       	ldd	r24, Y+3	; 0x03
    12a2:	88 2f       	mov	r24, r24
    12a4:	90 e0       	ldi	r25, 0x00	; 0
    12a6:	a9 01       	movw	r20, r18
    12a8:	02 c0       	rjmp	.+4      	; 0x12ae <GPIO_readPin+0xde>
    12aa:	55 95       	asr	r21
    12ac:	47 95       	ror	r20
    12ae:	8a 95       	dec	r24
    12b0:	e2 f7       	brpl	.-8      	; 0x12aa <GPIO_readPin+0xda>
    12b2:	ca 01       	movw	r24, r20
    12b4:	81 70       	andi	r24, 0x01	; 1
    12b6:	90 70       	andi	r25, 0x00	; 0
    12b8:	88 23       	and	r24, r24
    12ba:	19 f0       	breq	.+6      	; 0x12c2 <GPIO_readPin+0xf2>
			{
				pin_value = LOGIC_HIGH;
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	89 83       	std	Y+1, r24	; 0x01
    12c0:	19 c0       	rjmp	.+50     	; 0x12f4 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    12c2:	19 82       	std	Y+1, r1	; 0x01
    12c4:	17 c0       	rjmp	.+46     	; 0x12f4 <GPIO_readPin+0x124>
			}
			break;
		case PORTD_ID:
			if(BIT_IS_SET(PIND,pin_num))
    12c6:	e0 e3       	ldi	r30, 0x30	; 48
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	28 2f       	mov	r18, r24
    12ce:	30 e0       	ldi	r19, 0x00	; 0
    12d0:	8b 81       	ldd	r24, Y+3	; 0x03
    12d2:	88 2f       	mov	r24, r24
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	a9 01       	movw	r20, r18
    12d8:	02 c0       	rjmp	.+4      	; 0x12de <GPIO_readPin+0x10e>
    12da:	55 95       	asr	r21
    12dc:	47 95       	ror	r20
    12de:	8a 95       	dec	r24
    12e0:	e2 f7       	brpl	.-8      	; 0x12da <GPIO_readPin+0x10a>
    12e2:	ca 01       	movw	r24, r20
    12e4:	81 70       	andi	r24, 0x01	; 1
    12e6:	90 70       	andi	r25, 0x00	; 0
    12e8:	88 23       	and	r24, r24
    12ea:	19 f0       	breq	.+6      	; 0x12f2 <GPIO_readPin+0x122>
			{
				pin_value = LOGIC_HIGH;
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	89 83       	std	Y+1, r24	; 0x01
    12f0:	01 c0       	rjmp	.+2      	; 0x12f4 <GPIO_readPin+0x124>
			}
			else
			{
				pin_value = LOGIC_LOW;
    12f2:	19 82       	std	Y+1, r1	; 0x01
			}
			break;
		}
	}

	return pin_value;
    12f4:	89 81       	ldd	r24, Y+1	; 0x01
}
    12f6:	0f 90       	pop	r0
    12f8:	0f 90       	pop	r0
    12fa:	0f 90       	pop	r0
    12fc:	0f 90       	pop	r0
    12fe:	0f 90       	pop	r0
    1300:	cf 91       	pop	r28
    1302:	df 91       	pop	r29
    1304:	08 95       	ret

00001306 <GPIO_setupPortDirection>:
 * If the direction value is PORT_INPUT all pins in this port should be input pins.
 * If the direction value is PORT_OUTPUT all pins in this port should be output pins.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_setupPortDirection(uint8 port_num, GPIO_PortDirectionType direction)
{
    1306:	df 93       	push	r29
    1308:	cf 93       	push	r28
    130a:	00 d0       	rcall	.+0      	; 0x130c <GPIO_setupPortDirection+0x6>
    130c:	00 d0       	rcall	.+0      	; 0x130e <GPIO_setupPortDirection+0x8>
    130e:	cd b7       	in	r28, 0x3d	; 61
    1310:	de b7       	in	r29, 0x3e	; 62
    1312:	89 83       	std	Y+1, r24	; 0x01
    1314:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1316:	89 81       	ldd	r24, Y+1	; 0x01
    1318:	84 30       	cpi	r24, 0x04	; 4
    131a:	90 f5       	brcc	.+100    	; 0x1380 <GPIO_setupPortDirection+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Setup the port direction as required */
		switch(port_num)
    131c:	89 81       	ldd	r24, Y+1	; 0x01
    131e:	28 2f       	mov	r18, r24
    1320:	30 e0       	ldi	r19, 0x00	; 0
    1322:	3c 83       	std	Y+4, r19	; 0x04
    1324:	2b 83       	std	Y+3, r18	; 0x03
    1326:	8b 81       	ldd	r24, Y+3	; 0x03
    1328:	9c 81       	ldd	r25, Y+4	; 0x04
    132a:	81 30       	cpi	r24, 0x01	; 1
    132c:	91 05       	cpc	r25, r1
    132e:	d1 f0       	breq	.+52     	; 0x1364 <GPIO_setupPortDirection+0x5e>
    1330:	2b 81       	ldd	r18, Y+3	; 0x03
    1332:	3c 81       	ldd	r19, Y+4	; 0x04
    1334:	22 30       	cpi	r18, 0x02	; 2
    1336:	31 05       	cpc	r19, r1
    1338:	2c f4       	brge	.+10     	; 0x1344 <GPIO_setupPortDirection+0x3e>
    133a:	8b 81       	ldd	r24, Y+3	; 0x03
    133c:	9c 81       	ldd	r25, Y+4	; 0x04
    133e:	00 97       	sbiw	r24, 0x00	; 0
    1340:	61 f0       	breq	.+24     	; 0x135a <GPIO_setupPortDirection+0x54>
    1342:	1e c0       	rjmp	.+60     	; 0x1380 <GPIO_setupPortDirection+0x7a>
    1344:	2b 81       	ldd	r18, Y+3	; 0x03
    1346:	3c 81       	ldd	r19, Y+4	; 0x04
    1348:	22 30       	cpi	r18, 0x02	; 2
    134a:	31 05       	cpc	r19, r1
    134c:	81 f0       	breq	.+32     	; 0x136e <GPIO_setupPortDirection+0x68>
    134e:	8b 81       	ldd	r24, Y+3	; 0x03
    1350:	9c 81       	ldd	r25, Y+4	; 0x04
    1352:	83 30       	cpi	r24, 0x03	; 3
    1354:	91 05       	cpc	r25, r1
    1356:	81 f0       	breq	.+32     	; 0x1378 <GPIO_setupPortDirection+0x72>
    1358:	13 c0       	rjmp	.+38     	; 0x1380 <GPIO_setupPortDirection+0x7a>
		{
		case PORTA_ID:
			DDRA = direction;
    135a:	ea e3       	ldi	r30, 0x3A	; 58
    135c:	f0 e0       	ldi	r31, 0x00	; 0
    135e:	8a 81       	ldd	r24, Y+2	; 0x02
    1360:	80 83       	st	Z, r24
    1362:	0e c0       	rjmp	.+28     	; 0x1380 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTB_ID:
			DDRB = direction;
    1364:	e7 e3       	ldi	r30, 0x37	; 55
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	8a 81       	ldd	r24, Y+2	; 0x02
    136a:	80 83       	st	Z, r24
    136c:	09 c0       	rjmp	.+18     	; 0x1380 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTC_ID:
			DDRC = direction;
    136e:	e4 e3       	ldi	r30, 0x34	; 52
    1370:	f0 e0       	ldi	r31, 0x00	; 0
    1372:	8a 81       	ldd	r24, Y+2	; 0x02
    1374:	80 83       	st	Z, r24
    1376:	04 c0       	rjmp	.+8      	; 0x1380 <GPIO_setupPortDirection+0x7a>
			break;
		case PORTD_ID:
			DDRD = direction;
    1378:	e1 e3       	ldi	r30, 0x31	; 49
    137a:	f0 e0       	ldi	r31, 0x00	; 0
    137c:	8a 81       	ldd	r24, Y+2	; 0x02
    137e:	80 83       	st	Z, r24
			break;
		}
	}
}
    1380:	0f 90       	pop	r0
    1382:	0f 90       	pop	r0
    1384:	0f 90       	pop	r0
    1386:	0f 90       	pop	r0
    1388:	cf 91       	pop	r28
    138a:	df 91       	pop	r29
    138c:	08 95       	ret

0000138e <GPIO_writePort>:
 * If any pin in the port is output pin the value will be written.
 * If any pin in the port is input pin this will activate/deactivate the internal pull-up resistor.
 * If the input port number is not correct, The function will not handle the request.
 */
void GPIO_writePort(uint8 port_num, uint8 value)
{
    138e:	df 93       	push	r29
    1390:	cf 93       	push	r28
    1392:	00 d0       	rcall	.+0      	; 0x1394 <GPIO_writePort+0x6>
    1394:	00 d0       	rcall	.+0      	; 0x1396 <GPIO_writePort+0x8>
    1396:	cd b7       	in	r28, 0x3d	; 61
    1398:	de b7       	in	r29, 0x3e	; 62
    139a:	89 83       	std	Y+1, r24	; 0x01
    139c:	6a 83       	std	Y+2, r22	; 0x02
	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    139e:	89 81       	ldd	r24, Y+1	; 0x01
    13a0:	84 30       	cpi	r24, 0x04	; 4
    13a2:	90 f5       	brcc	.+100    	; 0x1408 <GPIO_writePort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Write the port value as required */
		switch(port_num)
    13a4:	89 81       	ldd	r24, Y+1	; 0x01
    13a6:	28 2f       	mov	r18, r24
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	3c 83       	std	Y+4, r19	; 0x04
    13ac:	2b 83       	std	Y+3, r18	; 0x03
    13ae:	8b 81       	ldd	r24, Y+3	; 0x03
    13b0:	9c 81       	ldd	r25, Y+4	; 0x04
    13b2:	81 30       	cpi	r24, 0x01	; 1
    13b4:	91 05       	cpc	r25, r1
    13b6:	d1 f0       	breq	.+52     	; 0x13ec <GPIO_writePort+0x5e>
    13b8:	2b 81       	ldd	r18, Y+3	; 0x03
    13ba:	3c 81       	ldd	r19, Y+4	; 0x04
    13bc:	22 30       	cpi	r18, 0x02	; 2
    13be:	31 05       	cpc	r19, r1
    13c0:	2c f4       	brge	.+10     	; 0x13cc <GPIO_writePort+0x3e>
    13c2:	8b 81       	ldd	r24, Y+3	; 0x03
    13c4:	9c 81       	ldd	r25, Y+4	; 0x04
    13c6:	00 97       	sbiw	r24, 0x00	; 0
    13c8:	61 f0       	breq	.+24     	; 0x13e2 <GPIO_writePort+0x54>
    13ca:	1e c0       	rjmp	.+60     	; 0x1408 <GPIO_writePort+0x7a>
    13cc:	2b 81       	ldd	r18, Y+3	; 0x03
    13ce:	3c 81       	ldd	r19, Y+4	; 0x04
    13d0:	22 30       	cpi	r18, 0x02	; 2
    13d2:	31 05       	cpc	r19, r1
    13d4:	81 f0       	breq	.+32     	; 0x13f6 <GPIO_writePort+0x68>
    13d6:	8b 81       	ldd	r24, Y+3	; 0x03
    13d8:	9c 81       	ldd	r25, Y+4	; 0x04
    13da:	83 30       	cpi	r24, 0x03	; 3
    13dc:	91 05       	cpc	r25, r1
    13de:	81 f0       	breq	.+32     	; 0x1400 <GPIO_writePort+0x72>
    13e0:	13 c0       	rjmp	.+38     	; 0x1408 <GPIO_writePort+0x7a>
		{
		case PORTA_ID:
			PORTA = value;
    13e2:	eb e3       	ldi	r30, 0x3B	; 59
    13e4:	f0 e0       	ldi	r31, 0x00	; 0
    13e6:	8a 81       	ldd	r24, Y+2	; 0x02
    13e8:	80 83       	st	Z, r24
    13ea:	0e c0       	rjmp	.+28     	; 0x1408 <GPIO_writePort+0x7a>
			break;
		case PORTB_ID:
			PORTB = value;
    13ec:	e8 e3       	ldi	r30, 0x38	; 56
    13ee:	f0 e0       	ldi	r31, 0x00	; 0
    13f0:	8a 81       	ldd	r24, Y+2	; 0x02
    13f2:	80 83       	st	Z, r24
    13f4:	09 c0       	rjmp	.+18     	; 0x1408 <GPIO_writePort+0x7a>
			break;
		case PORTC_ID:
			PORTC = value;
    13f6:	e5 e3       	ldi	r30, 0x35	; 53
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	8a 81       	ldd	r24, Y+2	; 0x02
    13fc:	80 83       	st	Z, r24
    13fe:	04 c0       	rjmp	.+8      	; 0x1408 <GPIO_writePort+0x7a>
			break;
		case PORTD_ID:
			PORTD = value;
    1400:	e2 e3       	ldi	r30, 0x32	; 50
    1402:	f0 e0       	ldi	r31, 0x00	; 0
    1404:	8a 81       	ldd	r24, Y+2	; 0x02
    1406:	80 83       	st	Z, r24
			break;
		}
	}
}
    1408:	0f 90       	pop	r0
    140a:	0f 90       	pop	r0
    140c:	0f 90       	pop	r0
    140e:	0f 90       	pop	r0
    1410:	cf 91       	pop	r28
    1412:	df 91       	pop	r29
    1414:	08 95       	ret

00001416 <GPIO_readPort>:
 * Description :
 * Read and return the value of the required port.
 * If the input port number is not correct, The function will return ZERO value.
 */
uint8 GPIO_readPort(uint8 port_num)
{
    1416:	df 93       	push	r29
    1418:	cf 93       	push	r28
    141a:	00 d0       	rcall	.+0      	; 0x141c <GPIO_readPort+0x6>
    141c:	00 d0       	rcall	.+0      	; 0x141e <GPIO_readPort+0x8>
    141e:	cd b7       	in	r28, 0x3d	; 61
    1420:	de b7       	in	r29, 0x3e	; 62
    1422:	8a 83       	std	Y+2, r24	; 0x02
	uint8 value = LOGIC_LOW;
    1424:	19 82       	std	Y+1, r1	; 0x01

	/*
	 * Check if the input number is greater than NUM_OF_PORTS value.
	 * In this case the input is not valid port number
	 */
	if(port_num >= NUM_OF_PORTS)
    1426:	8a 81       	ldd	r24, Y+2	; 0x02
    1428:	84 30       	cpi	r24, 0x04	; 4
    142a:	90 f5       	brcc	.+100    	; 0x1490 <GPIO_readPort+0x7a>
		/* Do Nothing */
	}
	else
	{
		/* Read the port value as required */
		switch(port_num)
    142c:	8a 81       	ldd	r24, Y+2	; 0x02
    142e:	28 2f       	mov	r18, r24
    1430:	30 e0       	ldi	r19, 0x00	; 0
    1432:	3c 83       	std	Y+4, r19	; 0x04
    1434:	2b 83       	std	Y+3, r18	; 0x03
    1436:	8b 81       	ldd	r24, Y+3	; 0x03
    1438:	9c 81       	ldd	r25, Y+4	; 0x04
    143a:	81 30       	cpi	r24, 0x01	; 1
    143c:	91 05       	cpc	r25, r1
    143e:	d1 f0       	breq	.+52     	; 0x1474 <GPIO_readPort+0x5e>
    1440:	2b 81       	ldd	r18, Y+3	; 0x03
    1442:	3c 81       	ldd	r19, Y+4	; 0x04
    1444:	22 30       	cpi	r18, 0x02	; 2
    1446:	31 05       	cpc	r19, r1
    1448:	2c f4       	brge	.+10     	; 0x1454 <GPIO_readPort+0x3e>
    144a:	8b 81       	ldd	r24, Y+3	; 0x03
    144c:	9c 81       	ldd	r25, Y+4	; 0x04
    144e:	00 97       	sbiw	r24, 0x00	; 0
    1450:	61 f0       	breq	.+24     	; 0x146a <GPIO_readPort+0x54>
    1452:	1e c0       	rjmp	.+60     	; 0x1490 <GPIO_readPort+0x7a>
    1454:	2b 81       	ldd	r18, Y+3	; 0x03
    1456:	3c 81       	ldd	r19, Y+4	; 0x04
    1458:	22 30       	cpi	r18, 0x02	; 2
    145a:	31 05       	cpc	r19, r1
    145c:	81 f0       	breq	.+32     	; 0x147e <GPIO_readPort+0x68>
    145e:	8b 81       	ldd	r24, Y+3	; 0x03
    1460:	9c 81       	ldd	r25, Y+4	; 0x04
    1462:	83 30       	cpi	r24, 0x03	; 3
    1464:	91 05       	cpc	r25, r1
    1466:	81 f0       	breq	.+32     	; 0x1488 <GPIO_readPort+0x72>
    1468:	13 c0       	rjmp	.+38     	; 0x1490 <GPIO_readPort+0x7a>
		{
		case PORTA_ID:
			value = PINA;
    146a:	e9 e3       	ldi	r30, 0x39	; 57
    146c:	f0 e0       	ldi	r31, 0x00	; 0
    146e:	80 81       	ld	r24, Z
    1470:	89 83       	std	Y+1, r24	; 0x01
    1472:	0e c0       	rjmp	.+28     	; 0x1490 <GPIO_readPort+0x7a>
			break;
		case PORTB_ID:
			value = PINB;
    1474:	e6 e3       	ldi	r30, 0x36	; 54
    1476:	f0 e0       	ldi	r31, 0x00	; 0
    1478:	80 81       	ld	r24, Z
    147a:	89 83       	std	Y+1, r24	; 0x01
    147c:	09 c0       	rjmp	.+18     	; 0x1490 <GPIO_readPort+0x7a>
			break;
		case PORTC_ID:
			value = PINC;
    147e:	e3 e3       	ldi	r30, 0x33	; 51
    1480:	f0 e0       	ldi	r31, 0x00	; 0
    1482:	80 81       	ld	r24, Z
    1484:	89 83       	std	Y+1, r24	; 0x01
    1486:	04 c0       	rjmp	.+8      	; 0x1490 <GPIO_readPort+0x7a>
			break;
		case PORTD_ID:
			value = PIND;
    1488:	e0 e3       	ldi	r30, 0x30	; 48
    148a:	f0 e0       	ldi	r31, 0x00	; 0
    148c:	80 81       	ld	r24, Z
    148e:	89 83       	std	Y+1, r24	; 0x01
			break;
		}
	}

	return value;
    1490:	89 81       	ldd	r24, Y+1	; 0x01
}
    1492:	0f 90       	pop	r0
    1494:	0f 90       	pop	r0
    1496:	0f 90       	pop	r0
    1498:	0f 90       	pop	r0
    149a:	cf 91       	pop	r28
    149c:	df 91       	pop	r29
    149e:	08 95       	ret

000014a0 <main>:
void open_door(void);
void error_handling(void);
void time_handler(void);

int main(void)
{
    14a0:	df 93       	push	r29
    14a2:	cf 93       	push	r28
    14a4:	cd b7       	in	r28, 0x3d	; 61
    14a6:	de b7       	in	r29, 0x3e	; 62
    14a8:	2d 97       	sbiw	r28, 0x0d	; 13
    14aa:	0f b6       	in	r0, 0x3f	; 63
    14ac:	f8 94       	cli
    14ae:	de bf       	out	0x3e, r29	; 62
    14b0:	0f be       	out	0x3f, r0	; 63
    14b2:	cd bf       	out	0x3d, r28	; 61
	uint8 response;

	/*******************************************************************************
	 *                           Initializations                                   *
	 *******************************************************************************/
	Buzzer_init();
    14b4:	0e 94 48 06 	call	0xc90	; 0xc90 <Buzzer_init>
	DcMotor_Init();
    14b8:	0e 94 a3 05 	call	0xb46	; 0xb46 <DcMotor_Init>
	PIR_init();
    14bc:	0e 94 d7 0c 	call	0x19ae	; 0x19ae <PIR_init>

	TWI_ConfigType config_twi = {0x01,rate_400k};
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	8a 83       	std	Y+2, r24	; 0x02
    14c4:	82 e0       	ldi	r24, 0x02	; 2
    14c6:	8b 83       	std	Y+3, r24	; 0x03
	TWI_init(&config_twi);
    14c8:	ce 01       	movw	r24, r28
    14ca:	02 96       	adiw	r24, 0x02	; 2
    14cc:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <TWI_init>

	UART_ConfigType config_uart = {bits_8,parity_disabled,stop_bit_1,BaudRate_9600};
    14d0:	ce 01       	movw	r24, r28
    14d2:	04 96       	adiw	r24, 0x04	; 4
    14d4:	9a 87       	std	Y+10, r25	; 0x0a
    14d6:	89 87       	std	Y+9, r24	; 0x09
    14d8:	e8 e6       	ldi	r30, 0x68	; 104
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	fc 87       	std	Y+12, r31	; 0x0c
    14de:	eb 87       	std	Y+11, r30	; 0x0b
    14e0:	f5 e0       	ldi	r31, 0x05	; 5
    14e2:	fd 87       	std	Y+13, r31	; 0x0d
    14e4:	eb 85       	ldd	r30, Y+11	; 0x0b
    14e6:	fc 85       	ldd	r31, Y+12	; 0x0c
    14e8:	00 80       	ld	r0, Z
    14ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    14ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    14ee:	01 96       	adiw	r24, 0x01	; 1
    14f0:	9c 87       	std	Y+12, r25	; 0x0c
    14f2:	8b 87       	std	Y+11, r24	; 0x0b
    14f4:	e9 85       	ldd	r30, Y+9	; 0x09
    14f6:	fa 85       	ldd	r31, Y+10	; 0x0a
    14f8:	00 82       	st	Z, r0
    14fa:	89 85       	ldd	r24, Y+9	; 0x09
    14fc:	9a 85       	ldd	r25, Y+10	; 0x0a
    14fe:	01 96       	adiw	r24, 0x01	; 1
    1500:	9a 87       	std	Y+10, r25	; 0x0a
    1502:	89 87       	std	Y+9, r24	; 0x09
    1504:	9d 85       	ldd	r25, Y+13	; 0x0d
    1506:	91 50       	subi	r25, 0x01	; 1
    1508:	9d 87       	std	Y+13, r25	; 0x0d
    150a:	ed 85       	ldd	r30, Y+13	; 0x0d
    150c:	ee 23       	and	r30, r30
    150e:	51 f7       	brne	.-44     	; 0x14e4 <main+0x44>
	UART_init(&config_uart);
    1510:	ce 01       	movw	r24, r28
    1512:	04 96       	adiw	r24, 0x04	; 4
    1514:	0e 94 db 0f 	call	0x1fb6	; 0x1fb6 <UART_init>

	Timer1_setCallBack(time_handler,TIMER1);
    1518:	87 e5       	ldi	r24, 0x57	; 87
    151a:	9c e0       	ldi	r25, 0x0C	; 12
    151c:	61 e0       	ldi	r22, 0x01	; 1
    151e:	0e 94 ea 0d 	call	0x1bd4	; 0x1bd4 <Timer1_setCallBack>

	while(UART_recieveByte() != MC1_READY){} // waiting for MC1 to be ready for synchronization
    1522:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    1526:	81 31       	cpi	r24, 0x11	; 17
    1528:	e1 f7       	brne	.-8      	; 0x1522 <main+0x82>

	while(1)
	{
		stay = 0; // to set stay to 0 for the while loop inside open_door function
    152a:	10 92 83 00 	sts	0x0083, r1

		response = UART_recieveByte(); // store the request of MC1 and choose what function to call according to it
    152e:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    1532:	89 83       	std	Y+1, r24	; 0x01
		if (response == set_pass)
    1534:	89 81       	ldd	r24, Y+1	; 0x01
    1536:	8f 3f       	cpi	r24, 0xFF	; 255
    1538:	19 f4       	brne	.+6      	; 0x1540 <main+0xa0>
		{
			set_password(); //function to set the password
    153a:	0e 94 b2 0a 	call	0x1564	; 0x1564 <set_password>
    153e:	f5 cf       	rjmp	.-22     	; 0x152a <main+0x8a>
		}
		else if (response == check_pass)
    1540:	89 81       	ldd	r24, Y+1	; 0x01
    1542:	81 3f       	cpi	r24, 0xF1	; 241
    1544:	19 f4       	brne	.+6      	; 0x154c <main+0xac>
		{
			check_password(); //function to check if the password is true
    1546:	0e 94 dc 0a 	call	0x15b8	; 0x15b8 <check_password>
    154a:	ef cf       	rjmp	.-34     	; 0x152a <main+0x8a>
		}

		else if (response == open)
    154c:	89 81       	ldd	r24, Y+1	; 0x01
    154e:	82 3f       	cpi	r24, 0xF2	; 242
    1550:	19 f4       	brne	.+6      	; 0x1558 <main+0xb8>
		{
			open_door(); // function to open the door
    1552:	0e 94 8c 0b 	call	0x1718	; 0x1718 <open_door>
    1556:	e9 cf       	rjmp	.-46     	; 0x152a <main+0x8a>
		}
		else if (response == ERRORR)
    1558:	89 81       	ldd	r24, Y+1	; 0x01
    155a:	83 3f       	cpi	r24, 0xF3	; 243
    155c:	31 f7       	brne	.-52     	; 0x152a <main+0x8a>
		{

			error_handling(); //function to make an alarm by the buzzer when the password is entered 3 times wrong
    155e:	0e 94 cb 0b 	call	0x1796	; 0x1796 <error_handling>
    1562:	e3 cf       	rjmp	.-58     	; 0x152a <main+0x8a>

00001564 <set_password>:
/*
 * Description :
 *function to set password by saving it inside the EEPROM.
 */
void set_password(void)
{
    1564:	df 93       	push	r29
    1566:	cf 93       	push	r28
    1568:	00 d0       	rcall	.+0      	; 0x156a <set_password+0x6>
    156a:	cd b7       	in	r28, 0x3d	; 61
    156c:	de b7       	in	r29, 0x3e	; 62
	uint8 i,key;
	for(i=0;i<5;i++)
    156e:	1a 82       	std	Y+2, r1	; 0x02
    1570:	14 c0       	rjmp	.+40     	; 0x159a <set_password+0x36>
	{
		UART_sendByte(MC2_READY);
    1572:	80 e1       	ldi	r24, 0x10	; 16
    1574:	0e 94 4b 10 	call	0x2096	; 0x2096 <UART_sendByte>
		key = UART_recieveByte();
    1578:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    157c:	89 83       	std	Y+1, r24	; 0x01
		EEPROM_writeByte(ADDRESS_1 + 4 * i, key);
    157e:	8a 81       	ldd	r24, Y+2	; 0x02
    1580:	88 2f       	mov	r24, r24
    1582:	90 e0       	ldi	r25, 0x00	; 0
    1584:	cc 96       	adiw	r24, 0x3c	; 60
    1586:	88 0f       	add	r24, r24
    1588:	99 1f       	adc	r25, r25
    158a:	88 0f       	add	r24, r24
    158c:	99 1f       	adc	r25, r25
    158e:	69 81       	ldd	r22, Y+1	; 0x01
    1590:	0e 94 71 06 	call	0xce2	; 0xce2 <EEPROM_writeByte>
 *function to set password by saving it inside the EEPROM.
 */
void set_password(void)
{
	uint8 i,key;
	for(i=0;i<5;i++)
    1594:	8a 81       	ldd	r24, Y+2	; 0x02
    1596:	8f 5f       	subi	r24, 0xFF	; 255
    1598:	8a 83       	std	Y+2, r24	; 0x02
    159a:	8a 81       	ldd	r24, Y+2	; 0x02
    159c:	85 30       	cpi	r24, 0x05	; 5
    159e:	48 f3       	brcs	.-46     	; 0x1572 <set_password+0xe>
	{
		UART_sendByte(MC2_READY);
		key = UART_recieveByte();
		EEPROM_writeByte(ADDRESS_1 + 4 * i, key);
	}
	while(UART_recieveByte() != MC1_READY){}
    15a0:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    15a4:	81 31       	cpi	r24, 0x11	; 17
    15a6:	e1 f7       	brne	.-8      	; 0x15a0 <set_password+0x3c>
	UART_sendByte(T);
    15a8:	81 e0       	ldi	r24, 0x01	; 1
    15aa:	0e 94 4b 10 	call	0x2096	; 0x2096 <UART_sendByte>
}
    15ae:	0f 90       	pop	r0
    15b0:	0f 90       	pop	r0
    15b2:	cf 91       	pop	r28
    15b4:	df 91       	pop	r29
    15b6:	08 95       	ret

000015b8 <check_password>:
 and compare it with it's one of the pin in the EEPROM and will send by the UART to MC1 to inform it
 that the entered password is true or false.
 */

void check_password(void)
{
    15b8:	df 93       	push	r29
    15ba:	cf 93       	push	r28
    15bc:	cd b7       	in	r28, 0x3d	; 61
    15be:	de b7       	in	r29, 0x3e	; 62
    15c0:	62 97       	sbiw	r28, 0x12	; 18
    15c2:	0f b6       	in	r0, 0x3f	; 63
    15c4:	f8 94       	cli
    15c6:	de bf       	out	0x3e, r29	; 62
    15c8:	0f be       	out	0x3f, r0	; 63
    15ca:	cd bf       	out	0x3d, r28	; 61
	uint8 i,key,check,response = T;
    15cc:	81 e0       	ldi	r24, 0x01	; 1
    15ce:	8f 87       	std	Y+15, r24	; 0x0f

	for(i=0;i<5;i++)
    15d0:	19 8a       	std	Y+17, r1	; 0x11
    15d2:	8e c0       	rjmp	.+284    	; 0x16f0 <check_password+0x138>
	{
		UART_sendByte(MC2_READY);
    15d4:	80 e1       	ldi	r24, 0x10	; 16
    15d6:	0e 94 4b 10 	call	0x2096	; 0x2096 <UART_sendByte>
		key = UART_recieveByte();
    15da:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    15de:	88 8b       	std	Y+16, r24	; 0x10
		EEPROM_readByte(ADDRESS_1 + 4 * i,&check);
    15e0:	89 89       	ldd	r24, Y+17	; 0x11
    15e2:	88 2f       	mov	r24, r24
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	cc 96       	adiw	r24, 0x3c	; 60
    15e8:	88 0f       	add	r24, r24
    15ea:	99 1f       	adc	r25, r25
    15ec:	88 0f       	add	r24, r24
    15ee:	99 1f       	adc	r25, r25
    15f0:	9e 01       	movw	r18, r28
    15f2:	2e 5e       	subi	r18, 0xEE	; 238
    15f4:	3f 4f       	sbci	r19, 0xFF	; 255
    15f6:	b9 01       	movw	r22, r18
    15f8:	0e 94 b2 06 	call	0xd64	; 0xd64 <EEPROM_readByte>
		if(key != check)
    15fc:	9a 89       	ldd	r25, Y+18	; 0x12
    15fe:	88 89       	ldd	r24, Y+16	; 0x10
    1600:	89 17       	cp	r24, r25
    1602:	09 f0       	breq	.+2      	; 0x1606 <check_password+0x4e>
		{
			response = F;
    1604:	1f 86       	std	Y+15, r1	; 0x0f
    1606:	80 e0       	ldi	r24, 0x00	; 0
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	aa ef       	ldi	r26, 0xFA	; 250
    160c:	b3 e4       	ldi	r27, 0x43	; 67
    160e:	8b 87       	std	Y+11, r24	; 0x0b
    1610:	9c 87       	std	Y+12, r25	; 0x0c
    1612:	ad 87       	std	Y+13, r26	; 0x0d
    1614:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    1616:	6b 85       	ldd	r22, Y+11	; 0x0b
    1618:	7c 85       	ldd	r23, Y+12	; 0x0c
    161a:	8d 85       	ldd	r24, Y+13	; 0x0d
    161c:	9e 85       	ldd	r25, Y+14	; 0x0e
    161e:	20 e0       	ldi	r18, 0x00	; 0
    1620:	30 e0       	ldi	r19, 0x00	; 0
    1622:	4a ef       	ldi	r20, 0xFA	; 250
    1624:	54 e4       	ldi	r21, 0x44	; 68
    1626:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    162a:	dc 01       	movw	r26, r24
    162c:	cb 01       	movw	r24, r22
    162e:	8f 83       	std	Y+7, r24	; 0x07
    1630:	98 87       	std	Y+8, r25	; 0x08
    1632:	a9 87       	std	Y+9, r26	; 0x09
    1634:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    1636:	6f 81       	ldd	r22, Y+7	; 0x07
    1638:	78 85       	ldd	r23, Y+8	; 0x08
    163a:	89 85       	ldd	r24, Y+9	; 0x09
    163c:	9a 85       	ldd	r25, Y+10	; 0x0a
    163e:	20 e0       	ldi	r18, 0x00	; 0
    1640:	30 e0       	ldi	r19, 0x00	; 0
    1642:	40 e8       	ldi	r20, 0x80	; 128
    1644:	5f e3       	ldi	r21, 0x3F	; 63
    1646:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    164a:	88 23       	and	r24, r24
    164c:	2c f4       	brge	.+10     	; 0x1658 <check_password+0xa0>
		__ticks = 1;
    164e:	81 e0       	ldi	r24, 0x01	; 1
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	9e 83       	std	Y+6, r25	; 0x06
    1654:	8d 83       	std	Y+5, r24	; 0x05
    1656:	3f c0       	rjmp	.+126    	; 0x16d6 <check_password+0x11e>
	else if (__tmp > 65535)
    1658:	6f 81       	ldd	r22, Y+7	; 0x07
    165a:	78 85       	ldd	r23, Y+8	; 0x08
    165c:	89 85       	ldd	r24, Y+9	; 0x09
    165e:	9a 85       	ldd	r25, Y+10	; 0x0a
    1660:	20 e0       	ldi	r18, 0x00	; 0
    1662:	3f ef       	ldi	r19, 0xFF	; 255
    1664:	4f e7       	ldi	r20, 0x7F	; 127
    1666:	57 e4       	ldi	r21, 0x47	; 71
    1668:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    166c:	18 16       	cp	r1, r24
    166e:	4c f5       	brge	.+82     	; 0x16c2 <check_password+0x10a>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    1670:	6b 85       	ldd	r22, Y+11	; 0x0b
    1672:	7c 85       	ldd	r23, Y+12	; 0x0c
    1674:	8d 85       	ldd	r24, Y+13	; 0x0d
    1676:	9e 85       	ldd	r25, Y+14	; 0x0e
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	30 e0       	ldi	r19, 0x00	; 0
    167c:	40 e2       	ldi	r20, 0x20	; 32
    167e:	51 e4       	ldi	r21, 0x41	; 65
    1680:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1684:	dc 01       	movw	r26, r24
    1686:	cb 01       	movw	r24, r22
    1688:	bc 01       	movw	r22, r24
    168a:	cd 01       	movw	r24, r26
    168c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    1690:	dc 01       	movw	r26, r24
    1692:	cb 01       	movw	r24, r22
    1694:	9e 83       	std	Y+6, r25	; 0x06
    1696:	8d 83       	std	Y+5, r24	; 0x05
    1698:	0f c0       	rjmp	.+30     	; 0x16b8 <check_password+0x100>
    169a:	88 ec       	ldi	r24, 0xC8	; 200
    169c:	90 e0       	ldi	r25, 0x00	; 0
    169e:	9c 83       	std	Y+4, r25	; 0x04
    16a0:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    16a2:	8b 81       	ldd	r24, Y+3	; 0x03
    16a4:	9c 81       	ldd	r25, Y+4	; 0x04
    16a6:	01 97       	sbiw	r24, 0x01	; 1
    16a8:	f1 f7       	brne	.-4      	; 0x16a6 <check_password+0xee>
    16aa:	9c 83       	std	Y+4, r25	; 0x04
    16ac:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    16ae:	8d 81       	ldd	r24, Y+5	; 0x05
    16b0:	9e 81       	ldd	r25, Y+6	; 0x06
    16b2:	01 97       	sbiw	r24, 0x01	; 1
    16b4:	9e 83       	std	Y+6, r25	; 0x06
    16b6:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    16b8:	8d 81       	ldd	r24, Y+5	; 0x05
    16ba:	9e 81       	ldd	r25, Y+6	; 0x06
    16bc:	00 97       	sbiw	r24, 0x00	; 0
    16be:	69 f7       	brne	.-38     	; 0x169a <check_password+0xe2>
    16c0:	14 c0       	rjmp	.+40     	; 0x16ea <check_password+0x132>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    16c2:	6f 81       	ldd	r22, Y+7	; 0x07
    16c4:	78 85       	ldd	r23, Y+8	; 0x08
    16c6:	89 85       	ldd	r24, Y+9	; 0x09
    16c8:	9a 85       	ldd	r25, Y+10	; 0x0a
    16ca:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    16ce:	dc 01       	movw	r26, r24
    16d0:	cb 01       	movw	r24, r22
    16d2:	9e 83       	std	Y+6, r25	; 0x06
    16d4:	8d 83       	std	Y+5, r24	; 0x05
    16d6:	8d 81       	ldd	r24, Y+5	; 0x05
    16d8:	9e 81       	ldd	r25, Y+6	; 0x06
    16da:	9a 83       	std	Y+2, r25	; 0x02
    16dc:	89 83       	std	Y+1, r24	; 0x01
    16de:	89 81       	ldd	r24, Y+1	; 0x01
    16e0:	9a 81       	ldd	r25, Y+2	; 0x02
    16e2:	01 97       	sbiw	r24, 0x01	; 1
    16e4:	f1 f7       	brne	.-4      	; 0x16e2 <check_password+0x12a>
    16e6:	9a 83       	std	Y+2, r25	; 0x02
    16e8:	89 83       	std	Y+1, r24	; 0x01

void check_password(void)
{
	uint8 i,key,check,response = T;

	for(i=0;i<5;i++)
    16ea:	89 89       	ldd	r24, Y+17	; 0x11
    16ec:	8f 5f       	subi	r24, 0xFF	; 255
    16ee:	89 8b       	std	Y+17, r24	; 0x11
    16f0:	89 89       	ldd	r24, Y+17	; 0x11
    16f2:	85 30       	cpi	r24, 0x05	; 5
    16f4:	08 f4       	brcc	.+2      	; 0x16f8 <check_password+0x140>
    16f6:	6e cf       	rjmp	.-292    	; 0x15d4 <check_password+0x1c>
		{
			response = F;
		}
		_delay_ms(500);
	}
	while(UART_recieveByte() != MC1_READY);
    16f8:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    16fc:	81 31       	cpi	r24, 0x11	; 17
    16fe:	e1 f7       	brne	.-8      	; 0x16f8 <check_password+0x140>
	UART_sendByte(response);
    1700:	8f 85       	ldd	r24, Y+15	; 0x0f
    1702:	0e 94 4b 10 	call	0x2096	; 0x2096 <UART_sendByte>
}
    1706:	62 96       	adiw	r28, 0x12	; 18
    1708:	0f b6       	in	r0, 0x3f	; 63
    170a:	f8 94       	cli
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	0f be       	out	0x3f, r0	; 63
    1710:	cd bf       	out	0x3d, r28	; 61
    1712:	cf 91       	pop	r28
    1714:	df 91       	pop	r29
    1716:	08 95       	ret

00001718 <open_door>:
 * Description :
 *function to open the vault as it make the motor rotate clockwise for 15seconds then it will wait for 3 seconds then
 *return anti-clockwise to close the vault
 */
void open_door(void)
{
    1718:	df 93       	push	r29
    171a:	cf 93       	push	r28
    171c:	cd b7       	in	r28, 0x3d	; 61
    171e:	de b7       	in	r29, 0x3e	; 62
    1720:	2c 97       	sbiw	r28, 0x0c	; 12
    1722:	0f b6       	in	r0, 0x3f	; 63
    1724:	f8 94       	cli
    1726:	de bf       	out	0x3e, r29	; 62
    1728:	0f be       	out	0x3f, r0	; 63
    172a:	cd bf       	out	0x3d, r28	; 61
	//uint8 check_pir =PIR_getState();
	DcMotor_Rotate(CW,252); // will order the motor to rotate clockwise direction
    172c:	82 e0       	ldi	r24, 0x02	; 2
    172e:	6c ef       	ldi	r22, 0xFC	; 252
    1730:	0e 94 c3 05 	call	0xb86	; 0xb86 <DcMotor_Rotate>
	Timer1_ConfigType config_timer = {0,58594,TIMER1,CLOCK_1024,COMPARE}; // set timer to give interrupt after 7.5seconds
    1734:	ce 01       	movw	r24, r28
    1736:	01 96       	adiw	r24, 0x01	; 1
    1738:	99 87       	std	Y+9, r25	; 0x09
    173a:	88 87       	std	Y+8, r24	; 0x08
    173c:	ed e6       	ldi	r30, 0x6D	; 109
    173e:	f0 e0       	ldi	r31, 0x00	; 0
    1740:	fb 87       	std	Y+11, r31	; 0x0b
    1742:	ea 87       	std	Y+10, r30	; 0x0a
    1744:	f7 e0       	ldi	r31, 0x07	; 7
    1746:	fc 87       	std	Y+12, r31	; 0x0c
    1748:	ea 85       	ldd	r30, Y+10	; 0x0a
    174a:	fb 85       	ldd	r31, Y+11	; 0x0b
    174c:	00 80       	ld	r0, Z
    174e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1750:	9b 85       	ldd	r25, Y+11	; 0x0b
    1752:	01 96       	adiw	r24, 0x01	; 1
    1754:	9b 87       	std	Y+11, r25	; 0x0b
    1756:	8a 87       	std	Y+10, r24	; 0x0a
    1758:	e8 85       	ldd	r30, Y+8	; 0x08
    175a:	f9 85       	ldd	r31, Y+9	; 0x09
    175c:	00 82       	st	Z, r0
    175e:	88 85       	ldd	r24, Y+8	; 0x08
    1760:	99 85       	ldd	r25, Y+9	; 0x09
    1762:	01 96       	adiw	r24, 0x01	; 1
    1764:	99 87       	std	Y+9, r25	; 0x09
    1766:	88 87       	std	Y+8, r24	; 0x08
    1768:	9c 85       	ldd	r25, Y+12	; 0x0c
    176a:	91 50       	subi	r25, 0x01	; 1
    176c:	9c 87       	std	Y+12, r25	; 0x0c
    176e:	ec 85       	ldd	r30, Y+12	; 0x0c
    1770:	ee 23       	and	r30, r30
    1772:	51 f7       	brne	.-44     	; 0x1748 <open_door+0x30>
	Timer1_init(&config_timer); // calling the initialization function of timer1 giving it the structure
    1774:	ce 01       	movw	r24, r28
    1776:	01 96       	adiw	r24, 0x01	; 1
    1778:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <Timer1_init>
	while (stay == 0); // we will be in this while until we are done with opening and closing the door
    177c:	80 91 83 00 	lds	r24, 0x0083
    1780:	88 23       	and	r24, r24
    1782:	e1 f3       	breq	.-8      	; 0x177c <open_door+0x64>
}
    1784:	2c 96       	adiw	r28, 0x0c	; 12
    1786:	0f b6       	in	r0, 0x3f	; 63
    1788:	f8 94       	cli
    178a:	de bf       	out	0x3e, r29	; 62
    178c:	0f be       	out	0x3f, r0	; 63
    178e:	cd bf       	out	0x3d, r28	; 61
    1790:	cf 91       	pop	r28
    1792:	df 91       	pop	r29
    1794:	08 95       	ret

00001796 <error_handling>:
/*
 * Description :
 *function to make buzzer on for 1-min upon entering the passworg wrong for 3 consecutive times
 */
void error_handling(void)
{
    1796:	df 93       	push	r29
    1798:	cf 93       	push	r28
    179a:	cd b7       	in	r28, 0x3d	; 61
    179c:	de b7       	in	r29, 0x3e	; 62
    179e:	2e 97       	sbiw	r28, 0x0e	; 14
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	f8 94       	cli
    17a4:	de bf       	out	0x3e, r29	; 62
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	cd bf       	out	0x3d, r28	; 61
	Buzzer_on();
    17aa:	0e 94 59 06 	call	0xcb2	; 0xcb2 <Buzzer_on>
	Timer1_deInit(TIMER1);
    17ae:	81 e0       	ldi	r24, 0x01	; 1
    17b0:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <Timer1_deInit>
    17b4:	80 e0       	ldi	r24, 0x00	; 0
    17b6:	90 e6       	ldi	r25, 0x60	; 96
    17b8:	aa e6       	ldi	r26, 0x6A	; 106
    17ba:	b7 e4       	ldi	r27, 0x47	; 71
    17bc:	8b 87       	std	Y+11, r24	; 0x0b
    17be:	9c 87       	std	Y+12, r25	; 0x0c
    17c0:	ad 87       	std	Y+13, r26	; 0x0d
    17c2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    17c4:	6b 85       	ldd	r22, Y+11	; 0x0b
    17c6:	7c 85       	ldd	r23, Y+12	; 0x0c
    17c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    17ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    17cc:	20 e0       	ldi	r18, 0x00	; 0
    17ce:	30 e0       	ldi	r19, 0x00	; 0
    17d0:	4a ef       	ldi	r20, 0xFA	; 250
    17d2:	54 e4       	ldi	r21, 0x44	; 68
    17d4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    17d8:	dc 01       	movw	r26, r24
    17da:	cb 01       	movw	r24, r22
    17dc:	8f 83       	std	Y+7, r24	; 0x07
    17de:	98 87       	std	Y+8, r25	; 0x08
    17e0:	a9 87       	std	Y+9, r26	; 0x09
    17e2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    17e4:	6f 81       	ldd	r22, Y+7	; 0x07
    17e6:	78 85       	ldd	r23, Y+8	; 0x08
    17e8:	89 85       	ldd	r24, Y+9	; 0x09
    17ea:	9a 85       	ldd	r25, Y+10	; 0x0a
    17ec:	20 e0       	ldi	r18, 0x00	; 0
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	40 e8       	ldi	r20, 0x80	; 128
    17f2:	5f e3       	ldi	r21, 0x3F	; 63
    17f4:	0e 94 79 03 	call	0x6f2	; 0x6f2 <__ltsf2>
    17f8:	88 23       	and	r24, r24
    17fa:	2c f4       	brge	.+10     	; 0x1806 <error_handling+0x70>
		__ticks = 1;
    17fc:	81 e0       	ldi	r24, 0x01	; 1
    17fe:	90 e0       	ldi	r25, 0x00	; 0
    1800:	9e 83       	std	Y+6, r25	; 0x06
    1802:	8d 83       	std	Y+5, r24	; 0x05
    1804:	3f c0       	rjmp	.+126    	; 0x1884 <error_handling+0xee>
	else if (__tmp > 65535)
    1806:	6f 81       	ldd	r22, Y+7	; 0x07
    1808:	78 85       	ldd	r23, Y+8	; 0x08
    180a:	89 85       	ldd	r24, Y+9	; 0x09
    180c:	9a 85       	ldd	r25, Y+10	; 0x0a
    180e:	20 e0       	ldi	r18, 0x00	; 0
    1810:	3f ef       	ldi	r19, 0xFF	; 255
    1812:	4f e7       	ldi	r20, 0x7F	; 127
    1814:	57 e4       	ldi	r21, 0x47	; 71
    1816:	0e 94 19 03 	call	0x632	; 0x632 <__gtsf2>
    181a:	18 16       	cp	r1, r24
    181c:	4c f5       	brge	.+82     	; 0x1870 <error_handling+0xda>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    181e:	6b 85       	ldd	r22, Y+11	; 0x0b
    1820:	7c 85       	ldd	r23, Y+12	; 0x0c
    1822:	8d 85       	ldd	r24, Y+13	; 0x0d
    1824:	9e 85       	ldd	r25, Y+14	; 0x0e
    1826:	20 e0       	ldi	r18, 0x00	; 0
    1828:	30 e0       	ldi	r19, 0x00	; 0
    182a:	40 e2       	ldi	r20, 0x20	; 32
    182c:	51 e4       	ldi	r21, 0x41	; 65
    182e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    1832:	dc 01       	movw	r26, r24
    1834:	cb 01       	movw	r24, r22
    1836:	bc 01       	movw	r22, r24
    1838:	cd 01       	movw	r24, r26
    183a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    183e:	dc 01       	movw	r26, r24
    1840:	cb 01       	movw	r24, r22
    1842:	9e 83       	std	Y+6, r25	; 0x06
    1844:	8d 83       	std	Y+5, r24	; 0x05
    1846:	0f c0       	rjmp	.+30     	; 0x1866 <error_handling+0xd0>
    1848:	88 ec       	ldi	r24, 0xC8	; 200
    184a:	90 e0       	ldi	r25, 0x00	; 0
    184c:	9c 83       	std	Y+4, r25	; 0x04
    184e:	8b 83       	std	Y+3, r24	; 0x03
    1850:	8b 81       	ldd	r24, Y+3	; 0x03
    1852:	9c 81       	ldd	r25, Y+4	; 0x04
    1854:	01 97       	sbiw	r24, 0x01	; 1
    1856:	f1 f7       	brne	.-4      	; 0x1854 <error_handling+0xbe>
    1858:	9c 83       	std	Y+4, r25	; 0x04
    185a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    185c:	8d 81       	ldd	r24, Y+5	; 0x05
    185e:	9e 81       	ldd	r25, Y+6	; 0x06
    1860:	01 97       	sbiw	r24, 0x01	; 1
    1862:	9e 83       	std	Y+6, r25	; 0x06
    1864:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    1866:	8d 81       	ldd	r24, Y+5	; 0x05
    1868:	9e 81       	ldd	r25, Y+6	; 0x06
    186a:	00 97       	sbiw	r24, 0x00	; 0
    186c:	69 f7       	brne	.-38     	; 0x1848 <error_handling+0xb2>
    186e:	14 c0       	rjmp	.+40     	; 0x1898 <error_handling+0x102>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    1870:	6f 81       	ldd	r22, Y+7	; 0x07
    1872:	78 85       	ldd	r23, Y+8	; 0x08
    1874:	89 85       	ldd	r24, Y+9	; 0x09
    1876:	9a 85       	ldd	r25, Y+10	; 0x0a
    1878:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    187c:	dc 01       	movw	r26, r24
    187e:	cb 01       	movw	r24, r22
    1880:	9e 83       	std	Y+6, r25	; 0x06
    1882:	8d 83       	std	Y+5, r24	; 0x05
    1884:	8d 81       	ldd	r24, Y+5	; 0x05
    1886:	9e 81       	ldd	r25, Y+6	; 0x06
    1888:	9a 83       	std	Y+2, r25	; 0x02
    188a:	89 83       	std	Y+1, r24	; 0x01
    188c:	89 81       	ldd	r24, Y+1	; 0x01
    188e:	9a 81       	ldd	r25, Y+2	; 0x02
    1890:	01 97       	sbiw	r24, 0x01	; 1
    1892:	f1 f7       	brne	.-4      	; 0x1890 <error_handling+0xfa>
    1894:	9a 83       	std	Y+2, r25	; 0x02
    1896:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(60000);
	Buzzer_off();
    1898:	0e 94 65 06 	call	0xcca	; 0xcca <Buzzer_off>
}
    189c:	2e 96       	adiw	r28, 0x0e	; 14
    189e:	0f b6       	in	r0, 0x3f	; 63
    18a0:	f8 94       	cli
    18a2:	de bf       	out	0x3e, r29	; 62
    18a4:	0f be       	out	0x3f, r0	; 63
    18a6:	cd bf       	out	0x3d, r28	; 61
    18a8:	cf 91       	pop	r28
    18aa:	df 91       	pop	r29
    18ac:	08 95       	ret

000018ae <time_handler>:
 * timer interrupt to 3 seconds on waiting state then change it again to 7.5 and give will return after 15 seconds after
 * de-initializing the timer to continue the program.
 */

void time_handler(void)
{
    18ae:	df 93       	push	r29
    18b0:	cf 93       	push	r28
    18b2:	cd b7       	in	r28, 0x3d	; 61
    18b4:	de b7       	in	r29, 0x3e	; 62
    18b6:	68 97       	sbiw	r28, 0x18	; 24
    18b8:	0f b6       	in	r0, 0x3f	; 63
    18ba:	f8 94       	cli
    18bc:	de bf       	out	0x3e, r29	; 62
    18be:	0f be       	out	0x3f, r0	; 63
    18c0:	cd bf       	out	0x3d, r28	; 61
	count++;
    18c2:	80 91 82 00 	lds	r24, 0x0082
    18c6:	8f 5f       	subi	r24, 0xFF	; 255
    18c8:	80 93 82 00 	sts	0x0082, r24
	if(count == 2)
    18cc:	80 91 82 00 	lds	r24, 0x0082
    18d0:	82 30       	cpi	r24, 0x02	; 2
    18d2:	41 f5       	brne	.+80     	; 0x1924 <time_handler+0x76>
	{
		DcMotor_Rotate(stop,0);  // will order the motor to stop rotation
    18d4:	80 e0       	ldi	r24, 0x00	; 0
    18d6:	60 e0       	ldi	r22, 0x00	; 0
    18d8:	0e 94 c3 05 	call	0xb86	; 0xb86 <DcMotor_Rotate>
		Timer1_ConfigType config_timer = {0,23438,TIMER1,CLOCK_1024,COMPARE}; // set timer to give interrupt after 3seconds
    18dc:	ce 01       	movw	r24, r28
    18de:	01 96       	adiw	r24, 0x01	; 1
    18e0:	98 8b       	std	Y+16, r25	; 0x10
    18e2:	8f 87       	std	Y+15, r24	; 0x0f
    18e4:	eb e7       	ldi	r30, 0x7B	; 123
    18e6:	f0 e0       	ldi	r31, 0x00	; 0
    18e8:	fa 8b       	std	Y+18, r31	; 0x12
    18ea:	e9 8b       	std	Y+17, r30	; 0x11
    18ec:	f7 e0       	ldi	r31, 0x07	; 7
    18ee:	fb 8b       	std	Y+19, r31	; 0x13
    18f0:	e9 89       	ldd	r30, Y+17	; 0x11
    18f2:	fa 89       	ldd	r31, Y+18	; 0x12
    18f4:	00 80       	ld	r0, Z
    18f6:	89 89       	ldd	r24, Y+17	; 0x11
    18f8:	9a 89       	ldd	r25, Y+18	; 0x12
    18fa:	01 96       	adiw	r24, 0x01	; 1
    18fc:	9a 8b       	std	Y+18, r25	; 0x12
    18fe:	89 8b       	std	Y+17, r24	; 0x11
    1900:	ef 85       	ldd	r30, Y+15	; 0x0f
    1902:	f8 89       	ldd	r31, Y+16	; 0x10
    1904:	00 82       	st	Z, r0
    1906:	8f 85       	ldd	r24, Y+15	; 0x0f
    1908:	98 89       	ldd	r25, Y+16	; 0x10
    190a:	01 96       	adiw	r24, 0x01	; 1
    190c:	98 8b       	std	Y+16, r25	; 0x10
    190e:	8f 87       	std	Y+15, r24	; 0x0f
    1910:	9b 89       	ldd	r25, Y+19	; 0x13
    1912:	91 50       	subi	r25, 0x01	; 1
    1914:	9b 8b       	std	Y+19, r25	; 0x13
    1916:	eb 89       	ldd	r30, Y+19	; 0x13
    1918:	ee 23       	and	r30, r30
    191a:	51 f7       	brne	.-44     	; 0x18f0 <time_handler+0x42>
		Timer1_init(&config_timer);
    191c:	ce 01       	movw	r24, r28
    191e:	01 96       	adiw	r24, 0x01	; 1
    1920:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <Timer1_init>
	}
	if (count == 3)
    1924:	80 91 82 00 	lds	r24, 0x0082
    1928:	83 30       	cpi	r24, 0x03	; 3
    192a:	41 f5       	brne	.+80     	; 0x197c <time_handler+0xce>
	{
		DcMotor_Rotate(CCW,252); // will order the motor to rotate anti-clockwise direction
    192c:	81 e0       	ldi	r24, 0x01	; 1
    192e:	6c ef       	ldi	r22, 0xFC	; 252
    1930:	0e 94 c3 05 	call	0xb86	; 0xb86 <DcMotor_Rotate>
		Timer1_ConfigType config_timer = {0,58594,TIMER1,CLOCK_1024,COMPARE}; // set timer to give interrupt after 7.5seconds
    1934:	ce 01       	movw	r24, r28
    1936:	08 96       	adiw	r24, 0x08	; 8
    1938:	9d 8b       	std	Y+21, r25	; 0x15
    193a:	8c 8b       	std	Y+20, r24	; 0x14
    193c:	e4 e7       	ldi	r30, 0x74	; 116
    193e:	f0 e0       	ldi	r31, 0x00	; 0
    1940:	ff 8b       	std	Y+23, r31	; 0x17
    1942:	ee 8b       	std	Y+22, r30	; 0x16
    1944:	f7 e0       	ldi	r31, 0x07	; 7
    1946:	f8 8f       	std	Y+24, r31	; 0x18
    1948:	ee 89       	ldd	r30, Y+22	; 0x16
    194a:	ff 89       	ldd	r31, Y+23	; 0x17
    194c:	00 80       	ld	r0, Z
    194e:	8e 89       	ldd	r24, Y+22	; 0x16
    1950:	9f 89       	ldd	r25, Y+23	; 0x17
    1952:	01 96       	adiw	r24, 0x01	; 1
    1954:	9f 8b       	std	Y+23, r25	; 0x17
    1956:	8e 8b       	std	Y+22, r24	; 0x16
    1958:	ec 89       	ldd	r30, Y+20	; 0x14
    195a:	fd 89       	ldd	r31, Y+21	; 0x15
    195c:	00 82       	st	Z, r0
    195e:	8c 89       	ldd	r24, Y+20	; 0x14
    1960:	9d 89       	ldd	r25, Y+21	; 0x15
    1962:	01 96       	adiw	r24, 0x01	; 1
    1964:	9d 8b       	std	Y+21, r25	; 0x15
    1966:	8c 8b       	std	Y+20, r24	; 0x14
    1968:	98 8d       	ldd	r25, Y+24	; 0x18
    196a:	91 50       	subi	r25, 0x01	; 1
    196c:	98 8f       	std	Y+24, r25	; 0x18
    196e:	e8 8d       	ldd	r30, Y+24	; 0x18
    1970:	ee 23       	and	r30, r30
    1972:	51 f7       	brne	.-44     	; 0x1948 <time_handler+0x9a>
		Timer1_init(&config_timer);
    1974:	ce 01       	movw	r24, r28
    1976:	08 96       	adiw	r24, 0x08	; 8
    1978:	0e 94 f8 0c 	call	0x19f0	; 0x19f0 <Timer1_init>

	}
	if (count == 5)
    197c:	80 91 82 00 	lds	r24, 0x0082
    1980:	85 30       	cpi	r24, 0x05	; 5
    1982:	61 f4       	brne	.+24     	; 0x199c <time_handler+0xee>
	{
		DcMotor_Rotate(stop,0);  // will order the motor to stop rotation
    1984:	80 e0       	ldi	r24, 0x00	; 0
    1986:	60 e0       	ldi	r22, 0x00	; 0
    1988:	0e 94 c3 05 	call	0xb86	; 0xb86 <DcMotor_Rotate>
		count = 0; // setting to 0 to reset everything to default
    198c:	10 92 82 00 	sts	0x0082, r1
		Timer1_deInit(TIMER1); // deinitialization of the timer
    1990:	81 e0       	ldi	r24, 0x01	; 1
    1992:	0e 94 b6 0d 	call	0x1b6c	; 0x1b6c <Timer1_deInit>
		stay = 1; // setting it to 1 will make us leave the while loop that we are stucked in the open door function
    1996:	81 e0       	ldi	r24, 0x01	; 1
    1998:	80 93 83 00 	sts	0x0083, r24

	}


}
    199c:	68 96       	adiw	r28, 0x18	; 24
    199e:	0f b6       	in	r0, 0x3f	; 63
    19a0:	f8 94       	cli
    19a2:	de bf       	out	0x3e, r29	; 62
    19a4:	0f be       	out	0x3f, r0	; 63
    19a6:	cd bf       	out	0x3d, r28	; 61
    19a8:	cf 91       	pop	r28
    19aa:	df 91       	pop	r29
    19ac:	08 95       	ret

000019ae <PIR_init>:
#include "pir.h"
#include <avr/io.h>
#include "gpio.h"
#include "common_macros.h"

void PIR_init(void){
    19ae:	df 93       	push	r29
    19b0:	cf 93       	push	r28
    19b2:	cd b7       	in	r28, 0x3d	; 61
    19b4:	de b7       	in	r29, 0x3e	; 62

	GPIO_setupPinDirection(PIR_PORT_ID,PIR_PIN_ID, PIN_OUTPUT);
    19b6:	82 e0       	ldi	r24, 0x02	; 2
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	41 e0       	ldi	r20, 0x01	; 1
    19bc:	0e 94 12 07 	call	0xe24	; 0xe24 <GPIO_setupPinDirection>
	GPIO_writePin(PIR_PORT_ID,PIR_PIN_ID, LOGIC_LOW);
    19c0:	82 e0       	ldi	r24, 0x02	; 2
    19c2:	62 e0       	ldi	r22, 0x02	; 2
    19c4:	40 e0       	ldi	r20, 0x00	; 0
    19c6:	0e 94 fd 07 	call	0xffa	; 0xffa <GPIO_writePin>

}
    19ca:	cf 91       	pop	r28
    19cc:	df 91       	pop	r29
    19ce:	08 95       	ret

000019d0 <PIR_getState>:

uint8 PIR_getState(void){
    19d0:	df 93       	push	r29
    19d2:	cf 93       	push	r28
    19d4:	0f 92       	push	r0
    19d6:	cd b7       	in	r28, 0x3d	; 61
    19d8:	de b7       	in	r29, 0x3e	; 62
	uint8 state=0;
    19da:	19 82       	std	Y+1, r1	; 0x01
	state= GPIO_readPin(PIR_PORT_ID,PIR_PIN_ID);
    19dc:	82 e0       	ldi	r24, 0x02	; 2
    19de:	62 e0       	ldi	r22, 0x02	; 2
    19e0:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <GPIO_readPin>
    19e4:	89 83       	std	Y+1, r24	; 0x01
	return state;
    19e6:	89 81       	ldd	r24, Y+1	; 0x01
}
    19e8:	0f 90       	pop	r0
    19ea:	cf 91       	pop	r28
    19ec:	df 91       	pop	r29
    19ee:	08 95       	ret

000019f0 <Timer1_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void Timer1_init(const Timer1_ConfigType * Config_Ptr)
{
    19f0:	df 93       	push	r29
    19f2:	cf 93       	push	r28
    19f4:	00 d0       	rcall	.+0      	; 0x19f6 <Timer1_init+0x6>
    19f6:	cd b7       	in	r28, 0x3d	; 61
    19f8:	de b7       	in	r29, 0x3e	; 62
    19fa:	9a 83       	std	Y+2, r25	; 0x02
    19fc:	89 83       	std	Y+1, r24	; 0x01
	SREG |= (1<<7);
    19fe:	af e5       	ldi	r26, 0x5F	; 95
    1a00:	b0 e0       	ldi	r27, 0x00	; 0
    1a02:	ef e5       	ldi	r30, 0x5F	; 95
    1a04:	f0 e0       	ldi	r31, 0x00	; 0
    1a06:	80 81       	ld	r24, Z
    1a08:	80 68       	ori	r24, 0x80	; 128
    1a0a:	8c 93       	st	X, r24

if(Config_Ptr ->timer_ID == TIMER1){
    1a0c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a0e:	fa 81       	ldd	r31, Y+2	; 0x02
    1a10:	84 81       	ldd	r24, Z+4	; 0x04
    1a12:	81 30       	cpi	r24, 0x01	; 1
    1a14:	e1 f5       	brne	.+120    	; 0x1a8e <Timer1_init+0x9e>
	TCNT1 = Config_Ptr->initial_value;
    1a16:	ac e4       	ldi	r26, 0x4C	; 76
    1a18:	b0 e0       	ldi	r27, 0x00	; 0
    1a1a:	e9 81       	ldd	r30, Y+1	; 0x01
    1a1c:	fa 81       	ldd	r31, Y+2	; 0x02
    1a1e:	80 81       	ld	r24, Z
    1a20:	91 81       	ldd	r25, Z+1	; 0x01
    1a22:	11 96       	adiw	r26, 0x01	; 1
    1a24:	9c 93       	st	X, r25
    1a26:	8e 93       	st	-X, r24

	if(Config_Ptr->mode == COMPARE)
    1a28:	e9 81       	ldd	r30, Y+1	; 0x01
    1a2a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a2c:	86 81       	ldd	r24, Z+6	; 0x06
    1a2e:	88 23       	and	r24, r24
    1a30:	c9 f4       	brne	.+50     	; 0x1a64 <Timer1_init+0x74>
	{
		OCR1A = Config_Ptr ->compare_value;
    1a32:	aa e4       	ldi	r26, 0x4A	; 74
    1a34:	b0 e0       	ldi	r27, 0x00	; 0
    1a36:	e9 81       	ldd	r30, Y+1	; 0x01
    1a38:	fa 81       	ldd	r31, Y+2	; 0x02
    1a3a:	82 81       	ldd	r24, Z+2	; 0x02
    1a3c:	93 81       	ldd	r25, Z+3	; 0x03
    1a3e:	11 96       	adiw	r26, 0x01	; 1
    1a40:	9c 93       	st	X, r25
    1a42:	8e 93       	st	-X, r24
		TIMSK = (1<<OCIE1A);
    1a44:	e9 e5       	ldi	r30, 0x59	; 89
    1a46:	f0 e0       	ldi	r31, 0x00	; 0
    1a48:	80 e1       	ldi	r24, 0x10	; 16
    1a4a:	80 83       	st	Z, r24
		TCCR1A = (1<<FOC1A);
    1a4c:	ef e4       	ldi	r30, 0x4F	; 79
    1a4e:	f0 e0       	ldi	r31, 0x00	; 0
    1a50:	88 e0       	ldi	r24, 0x08	; 8
    1a52:	80 83       	st	Z, r24
		TCCR1B = (1<<WGM12)|(Config_Ptr->prescaler);
    1a54:	ae e4       	ldi	r26, 0x4E	; 78
    1a56:	b0 e0       	ldi	r27, 0x00	; 0
    1a58:	e9 81       	ldd	r30, Y+1	; 0x01
    1a5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1a5c:	85 81       	ldd	r24, Z+5	; 0x05
    1a5e:	88 60       	ori	r24, 0x08	; 8
    1a60:	8c 93       	st	X, r24
    1a62:	7f c0       	rjmp	.+254    	; 0x1b62 <Timer1_init+0x172>
	}
	else if (Config_Ptr->mode == NORMAL)
    1a64:	e9 81       	ldd	r30, Y+1	; 0x01
    1a66:	fa 81       	ldd	r31, Y+2	; 0x02
    1a68:	86 81       	ldd	r24, Z+6	; 0x06
    1a6a:	81 30       	cpi	r24, 0x01	; 1
    1a6c:	09 f0       	breq	.+2      	; 0x1a70 <Timer1_init+0x80>
    1a6e:	79 c0       	rjmp	.+242    	; 0x1b62 <Timer1_init+0x172>
	{
		TIMSK = (1<<TOIE1);
    1a70:	e9 e5       	ldi	r30, 0x59	; 89
    1a72:	f0 e0       	ldi	r31, 0x00	; 0
    1a74:	84 e0       	ldi	r24, 0x04	; 4
    1a76:	80 83       	st	Z, r24
		TCCR1A = (1<<FOC1A);
    1a78:	ef e4       	ldi	r30, 0x4F	; 79
    1a7a:	f0 e0       	ldi	r31, 0x00	; 0
    1a7c:	88 e0       	ldi	r24, 0x08	; 8
    1a7e:	80 83       	st	Z, r24
		TCCR1B = (Config_Ptr->prescaler);
    1a80:	ae e4       	ldi	r26, 0x4E	; 78
    1a82:	b0 e0       	ldi	r27, 0x00	; 0
    1a84:	e9 81       	ldd	r30, Y+1	; 0x01
    1a86:	fa 81       	ldd	r31, Y+2	; 0x02
    1a88:	85 81       	ldd	r24, Z+5	; 0x05
    1a8a:	8c 93       	st	X, r24
    1a8c:	6a c0       	rjmp	.+212    	; 0x1b62 <Timer1_init+0x172>

	}
}
else if(Config_Ptr ->timer_ID == TIMER0){
    1a8e:	e9 81       	ldd	r30, Y+1	; 0x01
    1a90:	fa 81       	ldd	r31, Y+2	; 0x02
    1a92:	84 81       	ldd	r24, Z+4	; 0x04
    1a94:	88 23       	and	r24, r24
    1a96:	89 f5       	brne	.+98     	; 0x1afa <Timer1_init+0x10a>
	TCNT0 = Config_Ptr->initial_value;
    1a98:	a2 e5       	ldi	r26, 0x52	; 82
    1a9a:	b0 e0       	ldi	r27, 0x00	; 0
    1a9c:	e9 81       	ldd	r30, Y+1	; 0x01
    1a9e:	fa 81       	ldd	r31, Y+2	; 0x02
    1aa0:	80 81       	ld	r24, Z
    1aa2:	91 81       	ldd	r25, Z+1	; 0x01
    1aa4:	8c 93       	st	X, r24
	if(Config_Ptr->mode == COMPARE)
    1aa6:	e9 81       	ldd	r30, Y+1	; 0x01
    1aa8:	fa 81       	ldd	r31, Y+2	; 0x02
    1aaa:	86 81       	ldd	r24, Z+6	; 0x06
    1aac:	88 23       	and	r24, r24
    1aae:	99 f4       	brne	.+38     	; 0x1ad6 <Timer1_init+0xe6>
		{
			OCR0 = Config_Ptr ->compare_value;
    1ab0:	ac e5       	ldi	r26, 0x5C	; 92
    1ab2:	b0 e0       	ldi	r27, 0x00	; 0
    1ab4:	e9 81       	ldd	r30, Y+1	; 0x01
    1ab6:	fa 81       	ldd	r31, Y+2	; 0x02
    1ab8:	82 81       	ldd	r24, Z+2	; 0x02
    1aba:	93 81       	ldd	r25, Z+3	; 0x03
    1abc:	8c 93       	st	X, r24
			TIMSK = (1<<OCIE0);
    1abe:	e9 e5       	ldi	r30, 0x59	; 89
    1ac0:	f0 e0       	ldi	r31, 0x00	; 0
    1ac2:	82 e0       	ldi	r24, 0x02	; 2
    1ac4:	80 83       	st	Z, r24
			TCCR0 = (1<<WGM01)|(Config_Ptr->prescaler)|(1<<FOC0);
    1ac6:	a3 e5       	ldi	r26, 0x53	; 83
    1ac8:	b0 e0       	ldi	r27, 0x00	; 0
    1aca:	e9 81       	ldd	r30, Y+1	; 0x01
    1acc:	fa 81       	ldd	r31, Y+2	; 0x02
    1ace:	85 81       	ldd	r24, Z+5	; 0x05
    1ad0:	88 68       	ori	r24, 0x88	; 136
    1ad2:	8c 93       	st	X, r24
    1ad4:	46 c0       	rjmp	.+140    	; 0x1b62 <Timer1_init+0x172>

		}
		else if (Config_Ptr->mode == NORMAL)
    1ad6:	e9 81       	ldd	r30, Y+1	; 0x01
    1ad8:	fa 81       	ldd	r31, Y+2	; 0x02
    1ada:	86 81       	ldd	r24, Z+6	; 0x06
    1adc:	81 30       	cpi	r24, 0x01	; 1
    1ade:	09 f0       	breq	.+2      	; 0x1ae2 <Timer1_init+0xf2>
    1ae0:	40 c0       	rjmp	.+128    	; 0x1b62 <Timer1_init+0x172>
		{
			TIMSK = (1<<TOIE0);
    1ae2:	e9 e5       	ldi	r30, 0x59	; 89
    1ae4:	f0 e0       	ldi	r31, 0x00	; 0
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	80 83       	st	Z, r24
			TCCR0 = (Config_Ptr->prescaler)|(1<<FOC0);
    1aea:	a3 e5       	ldi	r26, 0x53	; 83
    1aec:	b0 e0       	ldi	r27, 0x00	; 0
    1aee:	e9 81       	ldd	r30, Y+1	; 0x01
    1af0:	fa 81       	ldd	r31, Y+2	; 0x02
    1af2:	85 81       	ldd	r24, Z+5	; 0x05
    1af4:	80 68       	ori	r24, 0x80	; 128
    1af6:	8c 93       	st	X, r24
    1af8:	34 c0       	rjmp	.+104    	; 0x1b62 <Timer1_init+0x172>

		}
}
else if(Config_Ptr ->timer_ID == TIMER0){
    1afa:	e9 81       	ldd	r30, Y+1	; 0x01
    1afc:	fa 81       	ldd	r31, Y+2	; 0x02
    1afe:	84 81       	ldd	r24, Z+4	; 0x04
    1b00:	88 23       	and	r24, r24
    1b02:	79 f5       	brne	.+94     	; 0x1b62 <Timer1_init+0x172>
	TCNT2 = Config_Ptr->initial_value;
    1b04:	a4 e4       	ldi	r26, 0x44	; 68
    1b06:	b0 e0       	ldi	r27, 0x00	; 0
    1b08:	e9 81       	ldd	r30, Y+1	; 0x01
    1b0a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b0c:	80 81       	ld	r24, Z
    1b0e:	91 81       	ldd	r25, Z+1	; 0x01
    1b10:	8c 93       	st	X, r24
	if(Config_Ptr->mode == COMPARE)
    1b12:	e9 81       	ldd	r30, Y+1	; 0x01
    1b14:	fa 81       	ldd	r31, Y+2	; 0x02
    1b16:	86 81       	ldd	r24, Z+6	; 0x06
    1b18:	88 23       	and	r24, r24
    1b1a:	99 f4       	brne	.+38     	; 0x1b42 <Timer1_init+0x152>
		{
			OCR2 = Config_Ptr ->compare_value;
    1b1c:	a3 e4       	ldi	r26, 0x43	; 67
    1b1e:	b0 e0       	ldi	r27, 0x00	; 0
    1b20:	e9 81       	ldd	r30, Y+1	; 0x01
    1b22:	fa 81       	ldd	r31, Y+2	; 0x02
    1b24:	82 81       	ldd	r24, Z+2	; 0x02
    1b26:	93 81       	ldd	r25, Z+3	; 0x03
    1b28:	8c 93       	st	X, r24
			TIMSK = (1<<OCIE2);
    1b2a:	e9 e5       	ldi	r30, 0x59	; 89
    1b2c:	f0 e0       	ldi	r31, 0x00	; 0
    1b2e:	80 e8       	ldi	r24, 0x80	; 128
    1b30:	80 83       	st	Z, r24
			TCCR0 = (1<<WGM21)|(Config_Ptr->prescaler)|(1<<FOC2);
    1b32:	a3 e5       	ldi	r26, 0x53	; 83
    1b34:	b0 e0       	ldi	r27, 0x00	; 0
    1b36:	e9 81       	ldd	r30, Y+1	; 0x01
    1b38:	fa 81       	ldd	r31, Y+2	; 0x02
    1b3a:	85 81       	ldd	r24, Z+5	; 0x05
    1b3c:	88 68       	ori	r24, 0x88	; 136
    1b3e:	8c 93       	st	X, r24
    1b40:	10 c0       	rjmp	.+32     	; 0x1b62 <Timer1_init+0x172>

		}
		else if (Config_Ptr->mode == NORMAL)
    1b42:	e9 81       	ldd	r30, Y+1	; 0x01
    1b44:	fa 81       	ldd	r31, Y+2	; 0x02
    1b46:	86 81       	ldd	r24, Z+6	; 0x06
    1b48:	81 30       	cpi	r24, 0x01	; 1
    1b4a:	59 f4       	brne	.+22     	; 0x1b62 <Timer1_init+0x172>
		{
			TIMSK = (1<<TOIE2);
    1b4c:	e9 e5       	ldi	r30, 0x59	; 89
    1b4e:	f0 e0       	ldi	r31, 0x00	; 0
    1b50:	80 e4       	ldi	r24, 0x40	; 64
    1b52:	80 83       	st	Z, r24
			TCCR0 = (Config_Ptr->prescaler)|(1<<FOC2);
    1b54:	a3 e5       	ldi	r26, 0x53	; 83
    1b56:	b0 e0       	ldi	r27, 0x00	; 0
    1b58:	e9 81       	ldd	r30, Y+1	; 0x01
    1b5a:	fa 81       	ldd	r31, Y+2	; 0x02
    1b5c:	85 81       	ldd	r24, Z+5	; 0x05
    1b5e:	80 68       	ori	r24, 0x80	; 128
    1b60:	8c 93       	st	X, r24

		}
}

}
    1b62:	0f 90       	pop	r0
    1b64:	0f 90       	pop	r0
    1b66:	cf 91       	pop	r28
    1b68:	df 91       	pop	r29
    1b6a:	08 95       	ret

00001b6c <Timer1_deInit>:

void Timer1_deInit(Timer_ID_TYPE timer_type)
{
    1b6c:	df 93       	push	r29
    1b6e:	cf 93       	push	r28
    1b70:	0f 92       	push	r0
    1b72:	cd b7       	in	r28, 0x3d	; 61
    1b74:	de b7       	in	r29, 0x3e	; 62
    1b76:	89 83       	std	Y+1, r24	; 0x01
	if(timer_type == TIMER1){
    1b78:	89 81       	ldd	r24, Y+1	; 0x01
    1b7a:	81 30       	cpi	r24, 0x01	; 1
    1b7c:	71 f4       	brne	.+28     	; 0x1b9a <Timer1_deInit+0x2e>
	TCNT1 = 0;
    1b7e:	ec e4       	ldi	r30, 0x4C	; 76
    1b80:	f0 e0       	ldi	r31, 0x00	; 0
    1b82:	11 82       	std	Z+1, r1	; 0x01
    1b84:	10 82       	st	Z, r1
	TCCR1A = 0;
    1b86:	ef e4       	ldi	r30, 0x4F	; 79
    1b88:	f0 e0       	ldi	r31, 0x00	; 0
    1b8a:	10 82       	st	Z, r1
	TCCR1B = 0;
    1b8c:	ee e4       	ldi	r30, 0x4E	; 78
    1b8e:	f0 e0       	ldi	r31, 0x00	; 0
    1b90:	10 82       	st	Z, r1
	TIMSK = 0;
    1b92:	e9 e5       	ldi	r30, 0x59	; 89
    1b94:	f0 e0       	ldi	r31, 0x00	; 0
    1b96:	10 82       	st	Z, r1
    1b98:	19 c0       	rjmp	.+50     	; 0x1bcc <Timer1_deInit+0x60>
	}
	else if(timer_type == TIMER0){
    1b9a:	89 81       	ldd	r24, Y+1	; 0x01
    1b9c:	88 23       	and	r24, r24
    1b9e:	51 f4       	brne	.+20     	; 0x1bb4 <Timer1_deInit+0x48>
		TCNT0 =0;
    1ba0:	e2 e5       	ldi	r30, 0x52	; 82
    1ba2:	f0 e0       	ldi	r31, 0x00	; 0
    1ba4:	10 82       	st	Z, r1
		TIMSK = 0;
    1ba6:	e9 e5       	ldi	r30, 0x59	; 89
    1ba8:	f0 e0       	ldi	r31, 0x00	; 0
    1baa:	10 82       	st	Z, r1
		TCCR0 = 0;
    1bac:	e3 e5       	ldi	r30, 0x53	; 83
    1bae:	f0 e0       	ldi	r31, 0x00	; 0
    1bb0:	10 82       	st	Z, r1
    1bb2:	0c c0       	rjmp	.+24     	; 0x1bcc <Timer1_deInit+0x60>
	}
	else if(timer_type == TIMER2){
    1bb4:	89 81       	ldd	r24, Y+1	; 0x01
    1bb6:	82 30       	cpi	r24, 0x02	; 2
    1bb8:	49 f4       	brne	.+18     	; 0x1bcc <Timer1_deInit+0x60>
			TCNT2 =0;
    1bba:	e4 e4       	ldi	r30, 0x44	; 68
    1bbc:	f0 e0       	ldi	r31, 0x00	; 0
    1bbe:	10 82       	st	Z, r1
			TIMSK = 0;
    1bc0:	e9 e5       	ldi	r30, 0x59	; 89
    1bc2:	f0 e0       	ldi	r31, 0x00	; 0
    1bc4:	10 82       	st	Z, r1
			TCCR2 = 0;
    1bc6:	e5 e4       	ldi	r30, 0x45	; 69
    1bc8:	f0 e0       	ldi	r31, 0x00	; 0
    1bca:	10 82       	st	Z, r1
		}


}
    1bcc:	0f 90       	pop	r0
    1bce:	cf 91       	pop	r28
    1bd0:	df 91       	pop	r29
    1bd2:	08 95       	ret

00001bd4 <Timer1_setCallBack>:

void Timer1_setCallBack(void(*a_ptr)(void),Timer_ID_TYPE timer_ID)
{
    1bd4:	df 93       	push	r29
    1bd6:	cf 93       	push	r28
    1bd8:	00 d0       	rcall	.+0      	; 0x1bda <Timer1_setCallBack+0x6>
    1bda:	00 d0       	rcall	.+0      	; 0x1bdc <Timer1_setCallBack+0x8>
    1bdc:	0f 92       	push	r0
    1bde:	cd b7       	in	r28, 0x3d	; 61
    1be0:	de b7       	in	r29, 0x3e	; 62
    1be2:	9a 83       	std	Y+2, r25	; 0x02
    1be4:	89 83       	std	Y+1, r24	; 0x01
    1be6:	6b 83       	std	Y+3, r22	; 0x03

	switch(timer_ID) {
    1be8:	8b 81       	ldd	r24, Y+3	; 0x03
    1bea:	28 2f       	mov	r18, r24
    1bec:	30 e0       	ldi	r19, 0x00	; 0
    1bee:	3d 83       	std	Y+5, r19	; 0x05
    1bf0:	2c 83       	std	Y+4, r18	; 0x04
    1bf2:	8c 81       	ldd	r24, Y+4	; 0x04
    1bf4:	9d 81       	ldd	r25, Y+5	; 0x05
    1bf6:	81 30       	cpi	r24, 0x01	; 1
    1bf8:	91 05       	cpc	r25, r1
    1bfa:	81 f0       	breq	.+32     	; 0x1c1c <Timer1_setCallBack+0x48>
    1bfc:	2c 81       	ldd	r18, Y+4	; 0x04
    1bfe:	3d 81       	ldd	r19, Y+5	; 0x05
    1c00:	22 30       	cpi	r18, 0x02	; 2
    1c02:	31 05       	cpc	r19, r1
    1c04:	91 f0       	breq	.+36     	; 0x1c2a <Timer1_setCallBack+0x56>
    1c06:	8c 81       	ldd	r24, Y+4	; 0x04
    1c08:	9d 81       	ldd	r25, Y+5	; 0x05
    1c0a:	00 97       	sbiw	r24, 0x00	; 0
    1c0c:	a1 f4       	brne	.+40     	; 0x1c36 <Timer1_setCallBack+0x62>
		case TIMER0:
			g_Timer0_CallBackPtr = a_ptr;
    1c0e:	89 81       	ldd	r24, Y+1	; 0x01
    1c10:	9a 81       	ldd	r25, Y+2	; 0x02
    1c12:	90 93 85 00 	sts	0x0085, r25
    1c16:	80 93 84 00 	sts	0x0084, r24
    1c1a:	0d c0       	rjmp	.+26     	; 0x1c36 <Timer1_setCallBack+0x62>
			break;
		case TIMER1:
			g_Timer1_CallBackPtr = a_ptr;
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	9a 81       	ldd	r25, Y+2	; 0x02
    1c20:	90 93 87 00 	sts	0x0087, r25
    1c24:	80 93 86 00 	sts	0x0086, r24
    1c28:	06 c0       	rjmp	.+12     	; 0x1c36 <Timer1_setCallBack+0x62>
			break;
		case TIMER2:
			g_Timer2_CallBackPtr = a_ptr;
    1c2a:	89 81       	ldd	r24, Y+1	; 0x01
    1c2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1c2e:	90 93 89 00 	sts	0x0089, r25
    1c32:	80 93 88 00 	sts	0x0088, r24
			break;
		}
}
    1c36:	0f 90       	pop	r0
    1c38:	0f 90       	pop	r0
    1c3a:	0f 90       	pop	r0
    1c3c:	0f 90       	pop	r0
    1c3e:	0f 90       	pop	r0
    1c40:	cf 91       	pop	r28
    1c42:	df 91       	pop	r29
    1c44:	08 95       	ret

00001c46 <__vector_11>:

/*******************************************************************************
 *                       Interrupt Service Routines                            *
 *******************************************************************************/

ISR(TIMER0_OVF_vect) {
    1c46:	1f 92       	push	r1
    1c48:	0f 92       	push	r0
    1c4a:	0f b6       	in	r0, 0x3f	; 63
    1c4c:	0f 92       	push	r0
    1c4e:	11 24       	eor	r1, r1
    1c50:	2f 93       	push	r18
    1c52:	3f 93       	push	r19
    1c54:	4f 93       	push	r20
    1c56:	5f 93       	push	r21
    1c58:	6f 93       	push	r22
    1c5a:	7f 93       	push	r23
    1c5c:	8f 93       	push	r24
    1c5e:	9f 93       	push	r25
    1c60:	af 93       	push	r26
    1c62:	bf 93       	push	r27
    1c64:	ef 93       	push	r30
    1c66:	ff 93       	push	r31
    1c68:	df 93       	push	r29
    1c6a:	cf 93       	push	r28
    1c6c:	cd b7       	in	r28, 0x3d	; 61
    1c6e:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer0_CallBackPtr != NULL_PTR) {
    1c70:	80 91 84 00 	lds	r24, 0x0084
    1c74:	90 91 85 00 	lds	r25, 0x0085
    1c78:	00 97       	sbiw	r24, 0x00	; 0
    1c7a:	29 f0       	breq	.+10     	; 0x1c86 <__vector_11+0x40>
		(*g_Timer0_CallBackPtr)();
    1c7c:	e0 91 84 00 	lds	r30, 0x0084
    1c80:	f0 91 85 00 	lds	r31, 0x0085
    1c84:	09 95       	icall
	}
}
    1c86:	cf 91       	pop	r28
    1c88:	df 91       	pop	r29
    1c8a:	ff 91       	pop	r31
    1c8c:	ef 91       	pop	r30
    1c8e:	bf 91       	pop	r27
    1c90:	af 91       	pop	r26
    1c92:	9f 91       	pop	r25
    1c94:	8f 91       	pop	r24
    1c96:	7f 91       	pop	r23
    1c98:	6f 91       	pop	r22
    1c9a:	5f 91       	pop	r21
    1c9c:	4f 91       	pop	r20
    1c9e:	3f 91       	pop	r19
    1ca0:	2f 91       	pop	r18
    1ca2:	0f 90       	pop	r0
    1ca4:	0f be       	out	0x3f, r0	; 63
    1ca6:	0f 90       	pop	r0
    1ca8:	1f 90       	pop	r1
    1caa:	18 95       	reti

00001cac <__vector_10>:

ISR(TIMER0_COMP_vect) {
    1cac:	1f 92       	push	r1
    1cae:	0f 92       	push	r0
    1cb0:	0f b6       	in	r0, 0x3f	; 63
    1cb2:	0f 92       	push	r0
    1cb4:	11 24       	eor	r1, r1
    1cb6:	2f 93       	push	r18
    1cb8:	3f 93       	push	r19
    1cba:	4f 93       	push	r20
    1cbc:	5f 93       	push	r21
    1cbe:	6f 93       	push	r22
    1cc0:	7f 93       	push	r23
    1cc2:	8f 93       	push	r24
    1cc4:	9f 93       	push	r25
    1cc6:	af 93       	push	r26
    1cc8:	bf 93       	push	r27
    1cca:	ef 93       	push	r30
    1ccc:	ff 93       	push	r31
    1cce:	df 93       	push	r29
    1cd0:	cf 93       	push	r28
    1cd2:	cd b7       	in	r28, 0x3d	; 61
    1cd4:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer0_CallBackPtr != NULL_PTR) {
    1cd6:	80 91 84 00 	lds	r24, 0x0084
    1cda:	90 91 85 00 	lds	r25, 0x0085
    1cde:	00 97       	sbiw	r24, 0x00	; 0
    1ce0:	29 f0       	breq	.+10     	; 0x1cec <__vector_10+0x40>
		(*g_Timer0_CallBackPtr)();
    1ce2:	e0 91 84 00 	lds	r30, 0x0084
    1ce6:	f0 91 85 00 	lds	r31, 0x0085
    1cea:	09 95       	icall
	}
}
    1cec:	cf 91       	pop	r28
    1cee:	df 91       	pop	r29
    1cf0:	ff 91       	pop	r31
    1cf2:	ef 91       	pop	r30
    1cf4:	bf 91       	pop	r27
    1cf6:	af 91       	pop	r26
    1cf8:	9f 91       	pop	r25
    1cfa:	8f 91       	pop	r24
    1cfc:	7f 91       	pop	r23
    1cfe:	6f 91       	pop	r22
    1d00:	5f 91       	pop	r21
    1d02:	4f 91       	pop	r20
    1d04:	3f 91       	pop	r19
    1d06:	2f 91       	pop	r18
    1d08:	0f 90       	pop	r0
    1d0a:	0f be       	out	0x3f, r0	; 63
    1d0c:	0f 90       	pop	r0
    1d0e:	1f 90       	pop	r1
    1d10:	18 95       	reti

00001d12 <__vector_9>:

ISR(TIMER1_OVF_vect) {
    1d12:	1f 92       	push	r1
    1d14:	0f 92       	push	r0
    1d16:	0f b6       	in	r0, 0x3f	; 63
    1d18:	0f 92       	push	r0
    1d1a:	11 24       	eor	r1, r1
    1d1c:	2f 93       	push	r18
    1d1e:	3f 93       	push	r19
    1d20:	4f 93       	push	r20
    1d22:	5f 93       	push	r21
    1d24:	6f 93       	push	r22
    1d26:	7f 93       	push	r23
    1d28:	8f 93       	push	r24
    1d2a:	9f 93       	push	r25
    1d2c:	af 93       	push	r26
    1d2e:	bf 93       	push	r27
    1d30:	ef 93       	push	r30
    1d32:	ff 93       	push	r31
    1d34:	df 93       	push	r29
    1d36:	cf 93       	push	r28
    1d38:	cd b7       	in	r28, 0x3d	; 61
    1d3a:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer1_CallBackPtr != NULL_PTR) {
    1d3c:	80 91 86 00 	lds	r24, 0x0086
    1d40:	90 91 87 00 	lds	r25, 0x0087
    1d44:	00 97       	sbiw	r24, 0x00	; 0
    1d46:	29 f0       	breq	.+10     	; 0x1d52 <__vector_9+0x40>
		(*g_Timer1_CallBackPtr)();
    1d48:	e0 91 86 00 	lds	r30, 0x0086
    1d4c:	f0 91 87 00 	lds	r31, 0x0087
    1d50:	09 95       	icall
	}
}
    1d52:	cf 91       	pop	r28
    1d54:	df 91       	pop	r29
    1d56:	ff 91       	pop	r31
    1d58:	ef 91       	pop	r30
    1d5a:	bf 91       	pop	r27
    1d5c:	af 91       	pop	r26
    1d5e:	9f 91       	pop	r25
    1d60:	8f 91       	pop	r24
    1d62:	7f 91       	pop	r23
    1d64:	6f 91       	pop	r22
    1d66:	5f 91       	pop	r21
    1d68:	4f 91       	pop	r20
    1d6a:	3f 91       	pop	r19
    1d6c:	2f 91       	pop	r18
    1d6e:	0f 90       	pop	r0
    1d70:	0f be       	out	0x3f, r0	; 63
    1d72:	0f 90       	pop	r0
    1d74:	1f 90       	pop	r1
    1d76:	18 95       	reti

00001d78 <__vector_7>:

ISR(TIMER1_COMPA_vect) {
    1d78:	1f 92       	push	r1
    1d7a:	0f 92       	push	r0
    1d7c:	0f b6       	in	r0, 0x3f	; 63
    1d7e:	0f 92       	push	r0
    1d80:	11 24       	eor	r1, r1
    1d82:	2f 93       	push	r18
    1d84:	3f 93       	push	r19
    1d86:	4f 93       	push	r20
    1d88:	5f 93       	push	r21
    1d8a:	6f 93       	push	r22
    1d8c:	7f 93       	push	r23
    1d8e:	8f 93       	push	r24
    1d90:	9f 93       	push	r25
    1d92:	af 93       	push	r26
    1d94:	bf 93       	push	r27
    1d96:	ef 93       	push	r30
    1d98:	ff 93       	push	r31
    1d9a:	df 93       	push	r29
    1d9c:	cf 93       	push	r28
    1d9e:	cd b7       	in	r28, 0x3d	; 61
    1da0:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer1_CallBackPtr != NULL_PTR) {
    1da2:	80 91 86 00 	lds	r24, 0x0086
    1da6:	90 91 87 00 	lds	r25, 0x0087
    1daa:	00 97       	sbiw	r24, 0x00	; 0
    1dac:	29 f0       	breq	.+10     	; 0x1db8 <__vector_7+0x40>
		(*g_Timer1_CallBackPtr)();
    1dae:	e0 91 86 00 	lds	r30, 0x0086
    1db2:	f0 91 87 00 	lds	r31, 0x0087
    1db6:	09 95       	icall
	}
}
    1db8:	cf 91       	pop	r28
    1dba:	df 91       	pop	r29
    1dbc:	ff 91       	pop	r31
    1dbe:	ef 91       	pop	r30
    1dc0:	bf 91       	pop	r27
    1dc2:	af 91       	pop	r26
    1dc4:	9f 91       	pop	r25
    1dc6:	8f 91       	pop	r24
    1dc8:	7f 91       	pop	r23
    1dca:	6f 91       	pop	r22
    1dcc:	5f 91       	pop	r21
    1dce:	4f 91       	pop	r20
    1dd0:	3f 91       	pop	r19
    1dd2:	2f 91       	pop	r18
    1dd4:	0f 90       	pop	r0
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	0f 90       	pop	r0
    1dda:	1f 90       	pop	r1
    1ddc:	18 95       	reti

00001dde <__vector_5>:

ISR(TIMER2_OVF_vect) {
    1dde:	1f 92       	push	r1
    1de0:	0f 92       	push	r0
    1de2:	0f b6       	in	r0, 0x3f	; 63
    1de4:	0f 92       	push	r0
    1de6:	11 24       	eor	r1, r1
    1de8:	2f 93       	push	r18
    1dea:	3f 93       	push	r19
    1dec:	4f 93       	push	r20
    1dee:	5f 93       	push	r21
    1df0:	6f 93       	push	r22
    1df2:	7f 93       	push	r23
    1df4:	8f 93       	push	r24
    1df6:	9f 93       	push	r25
    1df8:	af 93       	push	r26
    1dfa:	bf 93       	push	r27
    1dfc:	ef 93       	push	r30
    1dfe:	ff 93       	push	r31
    1e00:	df 93       	push	r29
    1e02:	cf 93       	push	r28
    1e04:	cd b7       	in	r28, 0x3d	; 61
    1e06:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer2_CallBackPtr != NULL_PTR) {
    1e08:	80 91 88 00 	lds	r24, 0x0088
    1e0c:	90 91 89 00 	lds	r25, 0x0089
    1e10:	00 97       	sbiw	r24, 0x00	; 0
    1e12:	29 f0       	breq	.+10     	; 0x1e1e <__vector_5+0x40>
		(*g_Timer2_CallBackPtr)();
    1e14:	e0 91 88 00 	lds	r30, 0x0088
    1e18:	f0 91 89 00 	lds	r31, 0x0089
    1e1c:	09 95       	icall
	}
}
    1e1e:	cf 91       	pop	r28
    1e20:	df 91       	pop	r29
    1e22:	ff 91       	pop	r31
    1e24:	ef 91       	pop	r30
    1e26:	bf 91       	pop	r27
    1e28:	af 91       	pop	r26
    1e2a:	9f 91       	pop	r25
    1e2c:	8f 91       	pop	r24
    1e2e:	7f 91       	pop	r23
    1e30:	6f 91       	pop	r22
    1e32:	5f 91       	pop	r21
    1e34:	4f 91       	pop	r20
    1e36:	3f 91       	pop	r19
    1e38:	2f 91       	pop	r18
    1e3a:	0f 90       	pop	r0
    1e3c:	0f be       	out	0x3f, r0	; 63
    1e3e:	0f 90       	pop	r0
    1e40:	1f 90       	pop	r1
    1e42:	18 95       	reti

00001e44 <__vector_4>:

ISR(TIMER2_COMP_vect) {
    1e44:	1f 92       	push	r1
    1e46:	0f 92       	push	r0
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	0f 92       	push	r0
    1e4c:	11 24       	eor	r1, r1
    1e4e:	2f 93       	push	r18
    1e50:	3f 93       	push	r19
    1e52:	4f 93       	push	r20
    1e54:	5f 93       	push	r21
    1e56:	6f 93       	push	r22
    1e58:	7f 93       	push	r23
    1e5a:	8f 93       	push	r24
    1e5c:	9f 93       	push	r25
    1e5e:	af 93       	push	r26
    1e60:	bf 93       	push	r27
    1e62:	ef 93       	push	r30
    1e64:	ff 93       	push	r31
    1e66:	df 93       	push	r29
    1e68:	cf 93       	push	r28
    1e6a:	cd b7       	in	r28, 0x3d	; 61
    1e6c:	de b7       	in	r29, 0x3e	; 62
	if(g_Timer2_CallBackPtr != NULL_PTR) {
    1e6e:	80 91 88 00 	lds	r24, 0x0088
    1e72:	90 91 89 00 	lds	r25, 0x0089
    1e76:	00 97       	sbiw	r24, 0x00	; 0
    1e78:	29 f0       	breq	.+10     	; 0x1e84 <__vector_4+0x40>
		(*g_Timer2_CallBackPtr)();
    1e7a:	e0 91 88 00 	lds	r30, 0x0088
    1e7e:	f0 91 89 00 	lds	r31, 0x0089
    1e82:	09 95       	icall
	}
}
    1e84:	cf 91       	pop	r28
    1e86:	df 91       	pop	r29
    1e88:	ff 91       	pop	r31
    1e8a:	ef 91       	pop	r30
    1e8c:	bf 91       	pop	r27
    1e8e:	af 91       	pop	r26
    1e90:	9f 91       	pop	r25
    1e92:	8f 91       	pop	r24
    1e94:	7f 91       	pop	r23
    1e96:	6f 91       	pop	r22
    1e98:	5f 91       	pop	r21
    1e9a:	4f 91       	pop	r20
    1e9c:	3f 91       	pop	r19
    1e9e:	2f 91       	pop	r18
    1ea0:	0f 90       	pop	r0
    1ea2:	0f be       	out	0x3f, r0	; 63
    1ea4:	0f 90       	pop	r0
    1ea6:	1f 90       	pop	r1
    1ea8:	18 95       	reti

00001eaa <TWI_init>:
/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/

void TWI_init(const TWI_ConfigType * Config_Ptr)
{
    1eaa:	df 93       	push	r29
    1eac:	cf 93       	push	r28
    1eae:	00 d0       	rcall	.+0      	; 0x1eb0 <TWI_init+0x6>
    1eb0:	cd b7       	in	r28, 0x3d	; 61
    1eb2:	de b7       	in	r29, 0x3e	; 62
    1eb4:	9a 83       	std	Y+2, r25	; 0x02
    1eb6:	89 83       	std	Y+1, r24	; 0x01
	/* Bit Rate: 400.000 kbps using zero pre-scaler TWPS=00 and F_CPU=8Mhz */
	TWBR = Config_Ptr ->bit_rate;
    1eb8:	a0 e2       	ldi	r26, 0x20	; 32
    1eba:	b0 e0       	ldi	r27, 0x00	; 0
    1ebc:	e9 81       	ldd	r30, Y+1	; 0x01
    1ebe:	fa 81       	ldd	r31, Y+2	; 0x02
    1ec0:	81 81       	ldd	r24, Z+1	; 0x01
    1ec2:	8c 93       	st	X, r24
	//  TWBR = 0x02;
	TWSR = 0x00;
    1ec4:	e1 e2       	ldi	r30, 0x21	; 33
    1ec6:	f0 e0       	ldi	r31, 0x00	; 0
    1ec8:	10 82       	st	Z, r1

	/* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
	TWAR = Config_Ptr ->address;
    1eca:	a2 e2       	ldi	r26, 0x22	; 34
    1ecc:	b0 e0       	ldi	r27, 0x00	; 0
    1ece:	e9 81       	ldd	r30, Y+1	; 0x01
    1ed0:	fa 81       	ldd	r31, Y+2	; 0x02
    1ed2:	80 81       	ld	r24, Z
    1ed4:	8c 93       	st	X, r24
	//   TWAR = 0b00000010; // my address = 0x01 :)

	TWCR = (1<<TWEN); /* enable TWI */
    1ed6:	e6 e5       	ldi	r30, 0x56	; 86
    1ed8:	f0 e0       	ldi	r31, 0x00	; 0
    1eda:	84 e0       	ldi	r24, 0x04	; 4
    1edc:	80 83       	st	Z, r24
}
    1ede:	0f 90       	pop	r0
    1ee0:	0f 90       	pop	r0
    1ee2:	cf 91       	pop	r28
    1ee4:	df 91       	pop	r29
    1ee6:	08 95       	ret

00001ee8 <TWI_start>:

void TWI_start(void)
{
    1ee8:	df 93       	push	r29
    1eea:	cf 93       	push	r28
    1eec:	cd b7       	in	r28, 0x3d	; 61
    1eee:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
	TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
    1ef0:	e6 e5       	ldi	r30, 0x56	; 86
    1ef2:	f0 e0       	ldi	r31, 0x00	; 0
    1ef4:	84 ea       	ldi	r24, 0xA4	; 164
    1ef6:	80 83       	st	Z, r24

	/* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
	while(BIT_IS_CLEAR(TWCR,TWINT));
    1ef8:	e6 e5       	ldi	r30, 0x56	; 86
    1efa:	f0 e0       	ldi	r31, 0x00	; 0
    1efc:	80 81       	ld	r24, Z
    1efe:	88 23       	and	r24, r24
    1f00:	dc f7       	brge	.-10     	; 0x1ef8 <TWI_start+0x10>
}
    1f02:	cf 91       	pop	r28
    1f04:	df 91       	pop	r29
    1f06:	08 95       	ret

00001f08 <TWI_stop>:

void TWI_stop(void)
{
    1f08:	df 93       	push	r29
    1f0a:	cf 93       	push	r28
    1f0c:	cd b7       	in	r28, 0x3d	; 61
    1f0e:	de b7       	in	r29, 0x3e	; 62
	/*
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1 
	 */
	TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
    1f10:	e6 e5       	ldi	r30, 0x56	; 86
    1f12:	f0 e0       	ldi	r31, 0x00	; 0
    1f14:	84 e9       	ldi	r24, 0x94	; 148
    1f16:	80 83       	st	Z, r24
}
    1f18:	cf 91       	pop	r28
    1f1a:	df 91       	pop	r29
    1f1c:	08 95       	ret

00001f1e <TWI_writeByte>:

void TWI_writeByte(uint8 data)
{
    1f1e:	df 93       	push	r29
    1f20:	cf 93       	push	r28
    1f22:	0f 92       	push	r0
    1f24:	cd b7       	in	r28, 0x3d	; 61
    1f26:	de b7       	in	r29, 0x3e	; 62
    1f28:	89 83       	std	Y+1, r24	; 0x01
	/* Put data On TWI data Register */
	TWDR = data;
    1f2a:	e3 e2       	ldi	r30, 0x23	; 35
    1f2c:	f0 e0       	ldi	r31, 0x00	; 0
    1f2e:	89 81       	ldd	r24, Y+1	; 0x01
    1f30:	80 83       	st	Z, r24
	/*
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */ 
	TWCR = (1 << TWINT) | (1 << TWEN);
    1f32:	e6 e5       	ldi	r30, 0x56	; 86
    1f34:	f0 e0       	ldi	r31, 0x00	; 0
    1f36:	84 e8       	ldi	r24, 0x84	; 132
    1f38:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register(data is send successfully) */
	while(BIT_IS_CLEAR(TWCR,TWINT));
    1f3a:	e6 e5       	ldi	r30, 0x56	; 86
    1f3c:	f0 e0       	ldi	r31, 0x00	; 0
    1f3e:	80 81       	ld	r24, Z
    1f40:	88 23       	and	r24, r24
    1f42:	dc f7       	brge	.-10     	; 0x1f3a <TWI_writeByte+0x1c>
}
    1f44:	0f 90       	pop	r0
    1f46:	cf 91       	pop	r28
    1f48:	df 91       	pop	r29
    1f4a:	08 95       	ret

00001f4c <TWI_readByteWithACK>:

uint8 TWI_readByteWithACK(void)
{
    1f4c:	df 93       	push	r29
    1f4e:	cf 93       	push	r28
    1f50:	cd b7       	in	r28, 0x3d	; 61
    1f52:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1 
	 */ 
	TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
    1f54:	e6 e5       	ldi	r30, 0x56	; 86
    1f56:	f0 e0       	ldi	r31, 0x00	; 0
    1f58:	84 ec       	ldi	r24, 0xC4	; 196
    1f5a:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while(BIT_IS_CLEAR(TWCR,TWINT));
    1f5c:	e6 e5       	ldi	r30, 0x56	; 86
    1f5e:	f0 e0       	ldi	r31, 0x00	; 0
    1f60:	80 81       	ld	r24, Z
    1f62:	88 23       	and	r24, r24
    1f64:	dc f7       	brge	.-10     	; 0x1f5c <TWI_readByteWithACK+0x10>
	/* Read Data */
	return TWDR;
    1f66:	e3 e2       	ldi	r30, 0x23	; 35
    1f68:	f0 e0       	ldi	r31, 0x00	; 0
    1f6a:	80 81       	ld	r24, Z
}
    1f6c:	cf 91       	pop	r28
    1f6e:	df 91       	pop	r29
    1f70:	08 95       	ret

00001f72 <TWI_readByteWithNACK>:

uint8 TWI_readByteWithNACK(void)
{
    1f72:	df 93       	push	r29
    1f74:	cf 93       	push	r28
    1f76:	cd b7       	in	r28, 0x3d	; 61
    1f78:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */
	TWCR = (1 << TWINT) | (1 << TWEN);
    1f7a:	e6 e5       	ldi	r30, 0x56	; 86
    1f7c:	f0 e0       	ldi	r31, 0x00	; 0
    1f7e:	84 e8       	ldi	r24, 0x84	; 132
    1f80:	80 83       	st	Z, r24
	/* Wait for TWINT flag set in TWCR Register (data received successfully) */
	while(BIT_IS_CLEAR(TWCR,TWINT));
    1f82:	e6 e5       	ldi	r30, 0x56	; 86
    1f84:	f0 e0       	ldi	r31, 0x00	; 0
    1f86:	80 81       	ld	r24, Z
    1f88:	88 23       	and	r24, r24
    1f8a:	dc f7       	brge	.-10     	; 0x1f82 <TWI_readByteWithNACK+0x10>
	/* Read Data */
	return TWDR;
    1f8c:	e3 e2       	ldi	r30, 0x23	; 35
    1f8e:	f0 e0       	ldi	r31, 0x00	; 0
    1f90:	80 81       	ld	r24, Z
}
    1f92:	cf 91       	pop	r28
    1f94:	df 91       	pop	r29
    1f96:	08 95       	ret

00001f98 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
    1f98:	df 93       	push	r29
    1f9a:	cf 93       	push	r28
    1f9c:	0f 92       	push	r0
    1f9e:	cd b7       	in	r28, 0x3d	; 61
    1fa0:	de b7       	in	r29, 0x3e	; 62
	uint8 status;
	/* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
	status = TWSR & 0xF8;
    1fa2:	e1 e2       	ldi	r30, 0x21	; 33
    1fa4:	f0 e0       	ldi	r31, 0x00	; 0
    1fa6:	80 81       	ld	r24, Z
    1fa8:	88 7f       	andi	r24, 0xF8	; 248
    1faa:	89 83       	std	Y+1, r24	; 0x01
	return status;
    1fac:	89 81       	ldd	r24, Y+1	; 0x01
}
    1fae:	0f 90       	pop	r0
    1fb0:	cf 91       	pop	r28
    1fb2:	df 91       	pop	r29
    1fb4:	08 95       	ret

00001fb6 <UART_init>:
 * 1. Setup the Frame format like number of data bits, parity bit type and number of stop bits.
 * 2. Enable the UART.
 * 3. Setup the UART baud rate.
 */
void UART_init(const UART_ConfigType * Config_Ptr)
{
    1fb6:	df 93       	push	r29
    1fb8:	cf 93       	push	r28
    1fba:	00 d0       	rcall	.+0      	; 0x1fbc <UART_init+0x6>
    1fbc:	00 d0       	rcall	.+0      	; 0x1fbe <UART_init+0x8>
    1fbe:	cd b7       	in	r28, 0x3d	; 61
    1fc0:	de b7       	in	r29, 0x3e	; 62
    1fc2:	9c 83       	std	Y+4, r25	; 0x04
    1fc4:	8b 83       	std	Y+3, r24	; 0x03
	uint16 ubrr_value = 0;
    1fc6:	1a 82       	std	Y+2, r1	; 0x02
    1fc8:	19 82       	std	Y+1, r1	; 0x01

	/* U2X = 1 for double transmission speed */
	UCSRA = (1<<U2X);
    1fca:	eb e2       	ldi	r30, 0x2B	; 43
    1fcc:	f0 e0       	ldi	r31, 0x00	; 0
    1fce:	82 e0       	ldi	r24, 0x02	; 2
    1fd0:	80 83       	st	Z, r24

	/************************** UCSRB Description **************************

	 ***********************************************************************/ 
	UCSRB = (1<<RXEN) | (1<<TXEN) | ((Config_Ptr ->bit_data & 0x04));
    1fd2:	aa e2       	ldi	r26, 0x2A	; 42
    1fd4:	b0 e0       	ldi	r27, 0x00	; 0
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	80 81       	ld	r24, Z
    1fdc:	84 70       	andi	r24, 0x04	; 4
    1fde:	88 61       	ori	r24, 0x18	; 24
    1fe0:	8c 93       	st	X, r24
	
	/************************** UCSRC Description **************************

	 ***********************************************************************/ 	
	UCSRC = (1<<URSEL) |((Config_Ptr ->bit_data & 0x03)<<1)|(Config_Ptr ->parity <<4)|(Config_Ptr ->stop_bit <<3);
    1fe2:	a0 e4       	ldi	r26, 0x40	; 64
    1fe4:	b0 e0       	ldi	r27, 0x00	; 0
    1fe6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fe8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fea:	80 81       	ld	r24, Z
    1fec:	88 2f       	mov	r24, r24
    1fee:	90 e0       	ldi	r25, 0x00	; 0
    1ff0:	83 70       	andi	r24, 0x03	; 3
    1ff2:	90 70       	andi	r25, 0x00	; 0
    1ff4:	88 0f       	add	r24, r24
    1ff6:	99 1f       	adc	r25, r25
    1ff8:	28 2f       	mov	r18, r24
    1ffa:	20 68       	ori	r18, 0x80	; 128
    1ffc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffe:	fc 81       	ldd	r31, Y+4	; 0x04
    2000:	81 81       	ldd	r24, Z+1	; 0x01
    2002:	88 2f       	mov	r24, r24
    2004:	90 e0       	ldi	r25, 0x00	; 0
    2006:	82 95       	swap	r24
    2008:	92 95       	swap	r25
    200a:	90 7f       	andi	r25, 0xF0	; 240
    200c:	98 27       	eor	r25, r24
    200e:	80 7f       	andi	r24, 0xF0	; 240
    2010:	98 27       	eor	r25, r24
    2012:	28 2b       	or	r18, r24
    2014:	eb 81       	ldd	r30, Y+3	; 0x03
    2016:	fc 81       	ldd	r31, Y+4	; 0x04
    2018:	82 81       	ldd	r24, Z+2	; 0x02
    201a:	88 2f       	mov	r24, r24
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	88 0f       	add	r24, r24
    2020:	99 1f       	adc	r25, r25
    2022:	88 0f       	add	r24, r24
    2024:	99 1f       	adc	r25, r25
    2026:	88 0f       	add	r24, r24
    2028:	99 1f       	adc	r25, r25
    202a:	82 2b       	or	r24, r18
    202c:	8c 93       	st	X, r24
	
	/* Calculate the UBRR register value */
	ubrr_value = (uint16)(((F_CPU / (Config_Ptr ->baud_rate * 8UL))) - 1);
    202e:	eb 81       	ldd	r30, Y+3	; 0x03
    2030:	fc 81       	ldd	r31, Y+4	; 0x04
    2032:	83 81       	ldd	r24, Z+3	; 0x03
    2034:	94 81       	ldd	r25, Z+4	; 0x04
    2036:	cc 01       	movw	r24, r24
    2038:	a0 e0       	ldi	r26, 0x00	; 0
    203a:	b0 e0       	ldi	r27, 0x00	; 0
    203c:	88 0f       	add	r24, r24
    203e:	99 1f       	adc	r25, r25
    2040:	aa 1f       	adc	r26, r26
    2042:	bb 1f       	adc	r27, r27
    2044:	88 0f       	add	r24, r24
    2046:	99 1f       	adc	r25, r25
    2048:	aa 1f       	adc	r26, r26
    204a:	bb 1f       	adc	r27, r27
    204c:	88 0f       	add	r24, r24
    204e:	99 1f       	adc	r25, r25
    2050:	aa 1f       	adc	r26, r26
    2052:	bb 1f       	adc	r27, r27
    2054:	9c 01       	movw	r18, r24
    2056:	ad 01       	movw	r20, r26
    2058:	80 e0       	ldi	r24, 0x00	; 0
    205a:	92 e1       	ldi	r25, 0x12	; 18
    205c:	aa e7       	ldi	r26, 0x7A	; 122
    205e:	b0 e0       	ldi	r27, 0x00	; 0
    2060:	bc 01       	movw	r22, r24
    2062:	cd 01       	movw	r24, r26
    2064:	0e 94 f1 10 	call	0x21e2	; 0x21e2 <__udivmodsi4>
    2068:	da 01       	movw	r26, r20
    206a:	c9 01       	movw	r24, r18
    206c:	01 97       	sbiw	r24, 0x01	; 1
    206e:	9a 83       	std	Y+2, r25	; 0x02
    2070:	89 83       	std	Y+1, r24	; 0x01

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	UBRRH = ubrr_value>>8;
    2072:	e0 e4       	ldi	r30, 0x40	; 64
    2074:	f0 e0       	ldi	r31, 0x00	; 0
    2076:	89 81       	ldd	r24, Y+1	; 0x01
    2078:	9a 81       	ldd	r25, Y+2	; 0x02
    207a:	89 2f       	mov	r24, r25
    207c:	99 27       	eor	r25, r25
    207e:	80 83       	st	Z, r24
	UBRRL = ubrr_value;
    2080:	e9 e2       	ldi	r30, 0x29	; 41
    2082:	f0 e0       	ldi	r31, 0x00	; 0
    2084:	89 81       	ldd	r24, Y+1	; 0x01
    2086:	80 83       	st	Z, r24
}
    2088:	0f 90       	pop	r0
    208a:	0f 90       	pop	r0
    208c:	0f 90       	pop	r0
    208e:	0f 90       	pop	r0
    2090:	cf 91       	pop	r28
    2092:	df 91       	pop	r29
    2094:	08 95       	ret

00002096 <UART_sendByte>:
/*
 * Description :
 * Functional responsible for send byte to another UART device.
 */
void UART_sendByte(const uint8 data)
{
    2096:	df 93       	push	r29
    2098:	cf 93       	push	r28
    209a:	0f 92       	push	r0
    209c:	cd b7       	in	r28, 0x3d	; 61
    209e:	de b7       	in	r29, 0x3e	; 62
    20a0:	89 83       	std	Y+1, r24	; 0x01
	/*
	 * UDRE flag is set when the Tx buffer (UDR) is empty and ready for
	 * transmitting a new byte so wait until this flag is set to one
	 */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
    20a2:	eb e2       	ldi	r30, 0x2B	; 43
    20a4:	f0 e0       	ldi	r31, 0x00	; 0
    20a6:	80 81       	ld	r24, Z
    20a8:	88 2f       	mov	r24, r24
    20aa:	90 e0       	ldi	r25, 0x00	; 0
    20ac:	80 72       	andi	r24, 0x20	; 32
    20ae:	90 70       	andi	r25, 0x00	; 0
    20b0:	00 97       	sbiw	r24, 0x00	; 0
    20b2:	b9 f3       	breq	.-18     	; 0x20a2 <UART_sendByte+0xc>

	/*
	 * Put the required data in the UDR register and it also clear the UDRE flag as
	 * the UDR register is not empty now
	 */
	UDR = data;
    20b4:	ec e2       	ldi	r30, 0x2C	; 44
    20b6:	f0 e0       	ldi	r31, 0x00	; 0
    20b8:	89 81       	ldd	r24, Y+1	; 0x01
    20ba:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transmission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	*******************************************************************/
}
    20bc:	0f 90       	pop	r0
    20be:	cf 91       	pop	r28
    20c0:	df 91       	pop	r29
    20c2:	08 95       	ret

000020c4 <UART_recieveByte>:
/*
 * Description :
 * Functional responsible for receive byte from another UART device.
 */
uint8 UART_recieveByte(void)
{
    20c4:	df 93       	push	r29
    20c6:	cf 93       	push	r28
    20c8:	cd b7       	in	r28, 0x3d	; 61
    20ca:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
    20cc:	eb e2       	ldi	r30, 0x2B	; 43
    20ce:	f0 e0       	ldi	r31, 0x00	; 0
    20d0:	80 81       	ld	r24, Z
    20d2:	88 23       	and	r24, r24
    20d4:	dc f7       	brge	.-10     	; 0x20cc <UART_recieveByte+0x8>

	/*
	 * Read the received data from the Rx buffer (UDR)
	 * The RXC flag will be cleared after read the data
	 */
    return UDR;		
    20d6:	ec e2       	ldi	r30, 0x2C	; 44
    20d8:	f0 e0       	ldi	r31, 0x00	; 0
    20da:	80 81       	ld	r24, Z
}
    20dc:	cf 91       	pop	r28
    20de:	df 91       	pop	r29
    20e0:	08 95       	ret

000020e2 <UART_sendString>:
/*
 * Description :
 * Send the required string through UART to the other UART device.
 */
void UART_sendString(const uint8 *Str)
{
    20e2:	df 93       	push	r29
    20e4:	cf 93       	push	r28
    20e6:	00 d0       	rcall	.+0      	; 0x20e8 <UART_sendString+0x6>
    20e8:	0f 92       	push	r0
    20ea:	cd b7       	in	r28, 0x3d	; 61
    20ec:	de b7       	in	r29, 0x3e	; 62
    20ee:	9b 83       	std	Y+3, r25	; 0x03
    20f0:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    20f2:	19 82       	std	Y+1, r1	; 0x01
    20f4:	0e c0       	rjmp	.+28     	; 0x2112 <UART_sendString+0x30>

	/* Send the whole string */
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
    20f6:	89 81       	ldd	r24, Y+1	; 0x01
    20f8:	28 2f       	mov	r18, r24
    20fa:	30 e0       	ldi	r19, 0x00	; 0
    20fc:	8a 81       	ldd	r24, Y+2	; 0x02
    20fe:	9b 81       	ldd	r25, Y+3	; 0x03
    2100:	fc 01       	movw	r30, r24
    2102:	e2 0f       	add	r30, r18
    2104:	f3 1f       	adc	r31, r19
    2106:	80 81       	ld	r24, Z
    2108:	0e 94 4b 10 	call	0x2096	; 0x2096 <UART_sendByte>
		i++;
    210c:	89 81       	ldd	r24, Y+1	; 0x01
    210e:	8f 5f       	subi	r24, 0xFF	; 255
    2110:	89 83       	std	Y+1, r24	; 0x01
void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;

	/* Send the whole string */
	while(Str[i] != '\0')
    2112:	89 81       	ldd	r24, Y+1	; 0x01
    2114:	28 2f       	mov	r18, r24
    2116:	30 e0       	ldi	r19, 0x00	; 0
    2118:	8a 81       	ldd	r24, Y+2	; 0x02
    211a:	9b 81       	ldd	r25, Y+3	; 0x03
    211c:	fc 01       	movw	r30, r24
    211e:	e2 0f       	add	r30, r18
    2120:	f3 1f       	adc	r31, r19
    2122:	80 81       	ld	r24, Z
    2124:	88 23       	and	r24, r24
    2126:	39 f7       	brne	.-50     	; 0x20f6 <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}		
	*******************************************************************/
}
    2128:	0f 90       	pop	r0
    212a:	0f 90       	pop	r0
    212c:	0f 90       	pop	r0
    212e:	cf 91       	pop	r28
    2130:	df 91       	pop	r29
    2132:	08 95       	ret

00002134 <UART_receiveString>:
/*
 * Description :
 * Receive the required string until the '#' symbol through UART from the other UART device.
 */
void UART_receiveString(uint8 *Str)
{
    2134:	0f 93       	push	r16
    2136:	1f 93       	push	r17
    2138:	df 93       	push	r29
    213a:	cf 93       	push	r28
    213c:	00 d0       	rcall	.+0      	; 0x213e <UART_receiveString+0xa>
    213e:	0f 92       	push	r0
    2140:	cd b7       	in	r28, 0x3d	; 61
    2142:	de b7       	in	r29, 0x3e	; 62
    2144:	9b 83       	std	Y+3, r25	; 0x03
    2146:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
    2148:	19 82       	std	Y+1, r1	; 0x01

	/* Receive the first byte */
	Str[i] = UART_recieveByte();
    214a:	89 81       	ldd	r24, Y+1	; 0x01
    214c:	28 2f       	mov	r18, r24
    214e:	30 e0       	ldi	r19, 0x00	; 0
    2150:	8a 81       	ldd	r24, Y+2	; 0x02
    2152:	9b 81       	ldd	r25, Y+3	; 0x03
    2154:	8c 01       	movw	r16, r24
    2156:	02 0f       	add	r16, r18
    2158:	13 1f       	adc	r17, r19
    215a:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    215e:	f8 01       	movw	r30, r16
    2160:	80 83       	st	Z, r24
    2162:	0f c0       	rjmp	.+30     	; 0x2182 <UART_receiveString+0x4e>

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
	{
		i++;
    2164:	89 81       	ldd	r24, Y+1	; 0x01
    2166:	8f 5f       	subi	r24, 0xFF	; 255
    2168:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
    216a:	89 81       	ldd	r24, Y+1	; 0x01
    216c:	28 2f       	mov	r18, r24
    216e:	30 e0       	ldi	r19, 0x00	; 0
    2170:	8a 81       	ldd	r24, Y+2	; 0x02
    2172:	9b 81       	ldd	r25, Y+3	; 0x03
    2174:	8c 01       	movw	r16, r24
    2176:	02 0f       	add	r16, r18
    2178:	13 1f       	adc	r17, r19
    217a:	0e 94 62 10 	call	0x20c4	; 0x20c4 <UART_recieveByte>
    217e:	f8 01       	movw	r30, r16
    2180:	80 83       	st	Z, r24

	/* Receive the first byte */
	Str[i] = UART_recieveByte();

	/* Receive the whole string until the '#' */
	while(Str[i] != '#')
    2182:	89 81       	ldd	r24, Y+1	; 0x01
    2184:	28 2f       	mov	r18, r24
    2186:	30 e0       	ldi	r19, 0x00	; 0
    2188:	8a 81       	ldd	r24, Y+2	; 0x02
    218a:	9b 81       	ldd	r25, Y+3	; 0x03
    218c:	fc 01       	movw	r30, r24
    218e:	e2 0f       	add	r30, r18
    2190:	f3 1f       	adc	r31, r19
    2192:	80 81       	ld	r24, Z
    2194:	83 32       	cpi	r24, 0x23	; 35
    2196:	31 f7       	brne	.-52     	; 0x2164 <UART_receiveString+0x30>
		i++;
		Str[i] = UART_recieveByte();
	}

	/* After receiving the whole string plus the '#', replace the '#' with '\0' */
	Str[i] = '\0';
    2198:	89 81       	ldd	r24, Y+1	; 0x01
    219a:	28 2f       	mov	r18, r24
    219c:	30 e0       	ldi	r19, 0x00	; 0
    219e:	8a 81       	ldd	r24, Y+2	; 0x02
    21a0:	9b 81       	ldd	r25, Y+3	; 0x03
    21a2:	fc 01       	movw	r30, r24
    21a4:	e2 0f       	add	r30, r18
    21a6:	f3 1f       	adc	r31, r19
    21a8:	10 82       	st	Z, r1
}
    21aa:	0f 90       	pop	r0
    21ac:	0f 90       	pop	r0
    21ae:	0f 90       	pop	r0
    21b0:	cf 91       	pop	r28
    21b2:	df 91       	pop	r29
    21b4:	1f 91       	pop	r17
    21b6:	0f 91       	pop	r16
    21b8:	08 95       	ret

000021ba <__udivmodhi4>:
    21ba:	aa 1b       	sub	r26, r26
    21bc:	bb 1b       	sub	r27, r27
    21be:	51 e1       	ldi	r21, 0x11	; 17
    21c0:	07 c0       	rjmp	.+14     	; 0x21d0 <__udivmodhi4_ep>

000021c2 <__udivmodhi4_loop>:
    21c2:	aa 1f       	adc	r26, r26
    21c4:	bb 1f       	adc	r27, r27
    21c6:	a6 17       	cp	r26, r22
    21c8:	b7 07       	cpc	r27, r23
    21ca:	10 f0       	brcs	.+4      	; 0x21d0 <__udivmodhi4_ep>
    21cc:	a6 1b       	sub	r26, r22
    21ce:	b7 0b       	sbc	r27, r23

000021d0 <__udivmodhi4_ep>:
    21d0:	88 1f       	adc	r24, r24
    21d2:	99 1f       	adc	r25, r25
    21d4:	5a 95       	dec	r21
    21d6:	a9 f7       	brne	.-22     	; 0x21c2 <__udivmodhi4_loop>
    21d8:	80 95       	com	r24
    21da:	90 95       	com	r25
    21dc:	bc 01       	movw	r22, r24
    21de:	cd 01       	movw	r24, r26
    21e0:	08 95       	ret

000021e2 <__udivmodsi4>:
    21e2:	a1 e2       	ldi	r26, 0x21	; 33
    21e4:	1a 2e       	mov	r1, r26
    21e6:	aa 1b       	sub	r26, r26
    21e8:	bb 1b       	sub	r27, r27
    21ea:	fd 01       	movw	r30, r26
    21ec:	0d c0       	rjmp	.+26     	; 0x2208 <__udivmodsi4_ep>

000021ee <__udivmodsi4_loop>:
    21ee:	aa 1f       	adc	r26, r26
    21f0:	bb 1f       	adc	r27, r27
    21f2:	ee 1f       	adc	r30, r30
    21f4:	ff 1f       	adc	r31, r31
    21f6:	a2 17       	cp	r26, r18
    21f8:	b3 07       	cpc	r27, r19
    21fa:	e4 07       	cpc	r30, r20
    21fc:	f5 07       	cpc	r31, r21
    21fe:	20 f0       	brcs	.+8      	; 0x2208 <__udivmodsi4_ep>
    2200:	a2 1b       	sub	r26, r18
    2202:	b3 0b       	sbc	r27, r19
    2204:	e4 0b       	sbc	r30, r20
    2206:	f5 0b       	sbc	r31, r21

00002208 <__udivmodsi4_ep>:
    2208:	66 1f       	adc	r22, r22
    220a:	77 1f       	adc	r23, r23
    220c:	88 1f       	adc	r24, r24
    220e:	99 1f       	adc	r25, r25
    2210:	1a 94       	dec	r1
    2212:	69 f7       	brne	.-38     	; 0x21ee <__udivmodsi4_loop>
    2214:	60 95       	com	r22
    2216:	70 95       	com	r23
    2218:	80 95       	com	r24
    221a:	90 95       	com	r25
    221c:	9b 01       	movw	r18, r22
    221e:	ac 01       	movw	r20, r24
    2220:	bd 01       	movw	r22, r26
    2222:	cf 01       	movw	r24, r30
    2224:	08 95       	ret

00002226 <__prologue_saves__>:
    2226:	2f 92       	push	r2
    2228:	3f 92       	push	r3
    222a:	4f 92       	push	r4
    222c:	5f 92       	push	r5
    222e:	6f 92       	push	r6
    2230:	7f 92       	push	r7
    2232:	8f 92       	push	r8
    2234:	9f 92       	push	r9
    2236:	af 92       	push	r10
    2238:	bf 92       	push	r11
    223a:	cf 92       	push	r12
    223c:	df 92       	push	r13
    223e:	ef 92       	push	r14
    2240:	ff 92       	push	r15
    2242:	0f 93       	push	r16
    2244:	1f 93       	push	r17
    2246:	cf 93       	push	r28
    2248:	df 93       	push	r29
    224a:	cd b7       	in	r28, 0x3d	; 61
    224c:	de b7       	in	r29, 0x3e	; 62
    224e:	ca 1b       	sub	r28, r26
    2250:	db 0b       	sbc	r29, r27
    2252:	0f b6       	in	r0, 0x3f	; 63
    2254:	f8 94       	cli
    2256:	de bf       	out	0x3e, r29	; 62
    2258:	0f be       	out	0x3f, r0	; 63
    225a:	cd bf       	out	0x3d, r28	; 61
    225c:	09 94       	ijmp

0000225e <__epilogue_restores__>:
    225e:	2a 88       	ldd	r2, Y+18	; 0x12
    2260:	39 88       	ldd	r3, Y+17	; 0x11
    2262:	48 88       	ldd	r4, Y+16	; 0x10
    2264:	5f 84       	ldd	r5, Y+15	; 0x0f
    2266:	6e 84       	ldd	r6, Y+14	; 0x0e
    2268:	7d 84       	ldd	r7, Y+13	; 0x0d
    226a:	8c 84       	ldd	r8, Y+12	; 0x0c
    226c:	9b 84       	ldd	r9, Y+11	; 0x0b
    226e:	aa 84       	ldd	r10, Y+10	; 0x0a
    2270:	b9 84       	ldd	r11, Y+9	; 0x09
    2272:	c8 84       	ldd	r12, Y+8	; 0x08
    2274:	df 80       	ldd	r13, Y+7	; 0x07
    2276:	ee 80       	ldd	r14, Y+6	; 0x06
    2278:	fd 80       	ldd	r15, Y+5	; 0x05
    227a:	0c 81       	ldd	r16, Y+4	; 0x04
    227c:	1b 81       	ldd	r17, Y+3	; 0x03
    227e:	aa 81       	ldd	r26, Y+2	; 0x02
    2280:	b9 81       	ldd	r27, Y+1	; 0x01
    2282:	ce 0f       	add	r28, r30
    2284:	d1 1d       	adc	r29, r1
    2286:	0f b6       	in	r0, 0x3f	; 63
    2288:	f8 94       	cli
    228a:	de bf       	out	0x3e, r29	; 62
    228c:	0f be       	out	0x3f, r0	; 63
    228e:	cd bf       	out	0x3d, r28	; 61
    2290:	ed 01       	movw	r28, r26
    2292:	08 95       	ret

00002294 <_exit>:
    2294:	f8 94       	cli

00002296 <__stop_program>:
    2296:	ff cf       	rjmp	.-2      	; 0x2296 <__stop_program>
